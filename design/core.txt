== SGS-UI design ==
-------- core -----

expected features:
- event-based system with realtime visual updating of specific regions

a basic example:
> initialize UI
> set frame color to gray, thus invalidating that region
> add button to frame, at position {x=200,y=200,width=200,height=100}, thus invalidating that region
> -- render pass --
> -- event: mousemove -> on button --
	> frame receives mouse-leave event
	> button receives mouse-enter event
		> some magic is done to change states, button region is invalidated
> -- render pass -- (button now has a hover style and it is rendered accordingly)
> -- event: mousedown -> ...
.... event: mouseup -> button receives event, cursor still on button, button emits an internal "click" event
	> subscribers of that event are called


rendering:
- a paint event is called that does the rendering
- it should be possible to have some abstract way to handle rendering, so that it would just be possible to define what's expected..
.. and pass that to the underlying rendering system that is hooked up

expected features:
- texture rectangle rendering
- gradient rendering
- texture masks
- shape masks

renderers are expected to optimize at least shape masks + tex.rect. rendering => textured polygons for GPUs
texture masks pretty much cannot be optimized (except for stencil + scissor rect)
shape masks + gradient rendering can be optimized if the gradient is first converted to an appropriately big texture (not safe)


UI Controls:
basic:
+ static control
+ button (text, with icon, icon only)
+ textbox (single-line)
extended:
+ scrollbar (H, V)
+ dropdown menu
/ listbox (scrollingautolayout + checkbox + static allows this quite easily)


==============
UI for EDITORS
--------------
special exts..

+ scrollable panels -- contents are scrollable, can contain anything
+ multi-level menus -- same as everywhere else
- possibly toolbars
+ different color themes
- tabbed panels (automatically assigning names to buttons)
- autocomplete popups (relative non-constrained overlays)
+ slidable panel splits (table with draggable borders)
- docking system (dockable window, docking hub)

a very common need:
DONE++> non-client areas for things like tabs and scrollbars
- essentially means there's a padding around the client area where nothing can exist
- it is still processed by the control's mouse click and other events but clients do not come into it with an additional AABB test to make sure

another need:
DONE++> forms. otherwise unnoticeable hubs for field data (textboxes, checkboxes, radio buttons, listboxes etc.)
+ textboxes should store data directly mapped
+ checkboxes should combine values into an array
+ radio buttons should clear other buttons with the same name, the value being the one picked
/ same goes for listboxes
+ combination of multiple values under the same name requires internal storage to be of array[string] type
+ requirement to retrieve different types of (possibly same) data means there must be the following functions to read it:
	- getData() returns a dict with `name => value-list` mapping
	- getList( name ) returns the data as array of values -- no data equals an empty array
	- getString( name ) returns the first item as string, if any -- otherwise null
/


--------------
OPTIMIZED AUTOMATIC LAYOUT SYSTEMS

- relative + absolute positioning (current)
- line/rect packing (to be added)

>> Layout Processing

/// examples \\\

== ACTION
layout root width++
== SETUP
layout root
{
	half-width float-left block 1
	half-width float-left block 2
	half-width float-left block 3
}
== IDEAL PROCESS
> layout root width increased
- layout root re-does the stacking layout from beginning, retrieving the to-be-used size values
- for each its child, layout root calls child layout update

== ACTION
hwflb 2 resized to full-width
== SETUP
- same
== IDEAL PROCESS
> hwflb 2 width increased
- hwflb 2 sees parent with child-dependent layout, hands control over to it, marking self as re-layouting start point
- layout root re-does the stacking layout from marked control, retrieving the to-be-used size values
- for each moved child, layout root calls child layout update


/// how to do partial recalc - where to put the data?
- each control can contain the layouting data that is produced after including it in the calculations


/// ======= \\\
|||  RULES  |||
\\\ ======= ///
 -- for on-layout-change processing

> if control is not stacked, it never triggers parent layout-recalc
> if control is stacked, it triggers parent layout-recalc and passes self as the starting point
> any change for any control triggers full child layout recalculation (both stacked and absolute for both parent/child)
> if stacked control has relative sizing in the direction that stacking (parent) control stretches, the behavior is undefined
> if stacked control has relative sizing in the direction that stacking (parent) control does not stretch, the sizing is fully obeyed

||| algorithm

> IF stacked-control AND parent-is-stacking
	> UPDATE parent FROM self
	> RETURN
/
> IF marked
	> FIND PREVIOUS FROM marked BACKWARDS OR INITIALIZE TO NULL
/
> FOR EACH stkctrl FROM marked OR start TO END
	> IF stkctrl.stacked-control
		> GENERATE LAYOUT FROM PREVIOUS PARSED TO stkctrl
	/
/
> UPDATE LAYOUT FOR self
> FOR EACH ctrl
	> UPDATE ctrl
/


> Scrollable control integration as a component
GOALS:
- (custom) scrollbar creation/destruction
- linking content overflow to scrollbar hiding/showing
- cursor scrolling

SOLUTION: control component system
component is a styleless, renderless event processing attachment with custom data slot made for it
struct UIComponent
{
	SGS_PROPERTY sgsString type;
	SGS_PROPERTY sgsVariable data;
	SGS_PROPERTY sgsVariable func;
};


