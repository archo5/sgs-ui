

global UI_Form = {};
function UI_Form.getData(){ return this.data.getData(); }
function UI_Form.getList( name ){ return this.data.getList( name ); }
function UI_Form.getString( name ){ return this.data.getString( name ); }

function UI_CreateForm( parent )
{
	Form = parent.frame.createControl( "form" );
	Form.data = { ctrls = map() };
	
	Form._interface = UI_Form;
	
	Form_data = Form.data;
	function Form_data.getData()
	{
		out = {};
		foreach( ctrl ,: this.ctrls )
		{
			val = ctrl.data.getValue();
			if( val !== null )
			{
				if( isset( out, ctrl.name ) )
					out[ ctrl.name ].push( val );
				else
					out[ ctrl.name ] = [ val ];
			}
			else
			{
				if( !isset( out, ctrl.name ) )
					out[ ctrl.name ] = [];
			}
		}
		return out;
	}
	function Form_data.getList( name )
	{
		out = [];
		foreach( ctrl ,: this.ctrls )
		{
			if( ctrl.name == name )
			{
				val = ctrl.data.getValue();
				if( val !== null )
				{
					if( typeof(val) !== "array" )
						out.push( val );
					else
						out = get_concat( out, val );
				}
			}
		}
		return out;
	}
	function Form_data.getString( name )
	{
		foreach( ctrl ,: this.ctrls )
		{
			if( ctrl.name == name )
			{
				val = ctrl.data.getValue();
				if( val !== null )
					return val;
			}
		}
		return null;
	}
	
	parent.addChild( Form );
	
	return Form;
}

function UIForm_GetFromCtrl( ctrl )
{
	while( ctrl )
	{
		if( ctrl.type == "form" )
			return ctrl;
		ctrl = ctrl.parent;
	}
	return null;
}

function UIForm_ChangeEvent( form, event )
{
	form.callEvent( "change", event );
}

function UIForm_Attach( ctrl, event )
{
	form = UIForm_GetFromCtrl( ctrl );
	if( form )
	{
		form.data.ctrls[ ctrl ] = true;
		UIForm_ChangeEvent( form, event );
	}
}

function UIForm_Detach( ctrl, event )
{
	form = UIForm_GetFromCtrl( ctrl );
	if( form )
	{
		unset( form.data.ctrls, ctrl );
		UIForm_ChangeEvent( form, event );
	}
}

function UIForm_CtrlChanged( ctrl, event )
{
	form = UIForm_GetFromCtrl( ctrl );
	if( form )
		UIForm_ChangeEvent( form, event );
}

function UIForm_ControlsByName( ctrl, name )
{
	form = UIForm_GetFromCtrl( ctrl );
	if( form )
	{
		out = [];
		foreach( c ,: form.data.ctrls )
		{
			if( c.name == name )
				out.push( c );
		}
		return out;
	}
	return [];
}


function UI_CreateHidden( parent, name, value )
{
	Hidden = parent.frame.createControl( "hidden" );
	Hidden.name = name;
	Hidden.data = { value = value };
	Hidden_data = Hidden.data;
	function Hidden_data.getValue(){ return this.value; }
	function Hidden.callback( event )
	{
		if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
	};
	return Hidden;
}

function UI_CreateCheckbox( parent, name, value, checked )
{
	Checkbox = parent.frame.createControl( "checkbox" );
	Checkbox.name = name;
	Checkbox.data =
	{
		checked = checked || false,
		value = value,
	};
	
	cbdata = Checkbox.data;
	
	function cbdata.getValue(){ return if( this.value === null, if( this.checked, 1, 0 ), if( this.checked, this.value, null ) ); };
	
	orig_callback = Checkbox.callback;
	function Checkbox.callback( event ) use( orig_callback )
	{
		data = this.data;
		
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Layout )
		{
			result = this!orig_callback( event );
			if( this.rx1 - this.rx0 < this.minWidth )
				this.rx1 = this.rx0 + this.minWidth;
			if( this.ry1 - this.ry0 < this.minHeight )
				this.ry1 = this.ry0 + this.minHeight;
			if( this.rx1 - this.rx0 > this.maxWidth )
			{
				diff = this.rx1 - this.rx0 - this.maxWidth;
				this.rx0 += diff * 0.5;
				this.rx1 = this.rx0 + this.maxWidth;
			}
			if( this.ry1 - this.ry0 > this.maxHeight )
			{
				diff = this.ry1 - this.ry0 - this.maxHeight;
				this.ry0 += diff * 0.5;
				this.ry1 = this.ry0 + this.maxHeight;
			}
			this._changedFullRect();
			return result;
		}
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == 0 && this.clicked && this == this.frame.getControlUnderCursor() )
			{
				data.checked = !data.checked;
				UIForm_CtrlChanged( this, event );
				this.callEvent( "change", event );
			}
		}
		return this!orig_callback( event );
	}
	
	Checkbox.updateTheme();
	parent.addChild( Checkbox );
	return Checkbox;
}

function UI_CreateRadioButton( parent, name, value, checked )
{
	RadioBtn = parent.frame.createControl( "radiobutton" );
	RadioBtn.name = name;
	RadioBtn.data =
	{
		checked = checked || false,
		value = if( value === null, 1, value ),
	};
	
	rbdata = RadioBtn.data;
	
	function rbdata.getValue(){ return if( this.checked, this.value, null ); };
	
	orig_callback = RadioBtn.callback;
	function RadioBtn.callback( event ) use( orig_callback )
	{
		data = this.data;
		
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Layout )
		{
			result = this!orig_callback( event );
			if( this.rx1 - this.rx0 < this.minWidth )
				this.rx1 = this.rx0 + this.minWidth;
			if( this.ry1 - this.ry0 < this.minHeight )
				this.ry1 = this.ry0 + this.minHeight;
			if( this.rx1 - this.rx0 > this.maxWidth )
			{
				diff = this.rx1 - this.rx0 - this.maxWidth;
				this.rx0 += diff * 0.5;
				this.rx1 = this.rx0 + this.maxWidth;
			}
			if( this.ry1 - this.ry0 > this.maxHeight )
			{
				diff = this.ry1 - this.ry0 - this.maxHeight;
				this.ry0 += diff * 0.5;
				this.ry1 = this.ry0 + this.maxHeight;
			}
			this._changedFullRect();
			return result;
		}
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == 0 && this.clicked && this == this.frame.getControlUnderCursor() )
			{
				ctrls = UIForm_ControlsByName( this, this.name );
				foreach( ctrl : ctrls )
				{
					if( ctrl.type == "radiobutton" && ctrl != this )
					{
						if( ctrl.data.checked != false )
						{
							ctrl.data.checked = false;
							ctrl.callEvent( "change", event );
							UIForm_CtrlChanged( this, event );
						}
					}
				}
				if( data.checked != true )
				{
					data.checked = true;
					this.callEvent( "change", event );
					UIForm_CtrlChanged( this, event );
				}
			}
		}
		return this!orig_callback( event );
	}
	
	RadioBtn.updateTheme();
	
	parent.addChild( RadioBtn );
	
	return RadioBtn;
}


function UI_CreateTextbox( parent, name, caption, text )
{
	caption ||= "";
	text ||= "";
	text = tostring( text );
	
	Textbox = parent.frame.createControl( "textbox" );
	Textbox.name = name;
	Textbox.cursor = UI_Cursor_Text;
	
	Textbox.data =
	{
		padding = 1,
		text_padding = 2,
		caption = caption,
		
		offset = 0,
		sel_from = text.length,
		sel_to = text.length,
		fsel_from = null,
		fsel_to = null,
		selecting = false,
		chars = string_utf8_decode( text ),
		text = text,
		prevtext = text,
		show_cursor = true,
		cursor_timer = null,
	};
	
	tbdata = Textbox.data;
	
	function tbdata.getValue(){ return this.text; }
	
	function tbdata.removeCursorTimer( frame )
	{
		if( this.cursor_timer )
			frame.clearInterval( this.cursor_timer );
		this.cursor_timer = null;
	}
	function tbdata.resetCursorTimer( frame )
	{
		tbdata = this;
		this.removeCursorTimer( frame );
		this.cursor_timer = frame.setInterval( 0.5, function() use( tbdata ) { tbdata.show_cursor = !tbdata.show_cursor; } );
		this.show_cursor = true;
	}
	
	function tbdata.updateSelOffsets( Textbox )
	{
		this.sel_from = max( 0, min( this.sel_from, this.chars.size ) );
		this.sel_to = max( 0, min( this.sel_to, this.chars.size ) );
		this.fsel_to = 0;
		this.fsel_from = 0;
		
		pc = null;
		for( i = 0; i < this.sel_from; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_from += Textbox._cachedFont.getAdvance( pc, ch );
			pc = ch;
		}
		
		pc = null;
		for( i = 0; i < this.sel_to; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_to += Textbox._cachedFont.getAdvance( pc, ch );
			pc = ch;
		}
	}
	
	function tbdata.updateText()
	{
		this.text = string_utf8_encode( this.chars );
	}
	
	function tbdata.findOffset( ctrl, x, y )
	{
		cpad = this.padding + this.text_padding;
		x -= ctrl.rx0 + cpad - this.offset;
		y -= ctrl.ry0 + cpad;
		
		fmin = 0.0;
		fmax = 0.0;
		pc = null;
		for( i = 0; i < this.chars.size; ++i )
		{
			ch = this.chars[ i ];
			fmax += ctrl._cachedFont.getAdvance( pc, ch );
			if( x <= (fmin+fmax)*0.5 )
				break;
			fmin = fmax;
			pc = ch;
		}
		return i;
	}
	
	tbdata.updateSelOffsets( Textbox );
	
	ocb = Textbox.callback;
	function Textbox.callback( event ) use( ocb )
	{
		data = this.data;
		
		if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
			data.removeCursorTimer( this.frame );
		}
		else if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_FocusEnter )
		{
			data.prevtext = data.text;
			data.resetCursorTimer( this.frame );
		}
		else if( event.type == EV_FocusLeave )
		{
			data.removeCursorTimer( this.frame );
			if( data.prevtext != data.text )
			{
				this.callEvent( "commit", event );
				UIForm_CtrlChanged( this, event );
			}
		}
		else if( event.type == EV_Char )
		{
			if( event.uchar > 0x1f && event.uchar != 0x7f )
			{
				if( data.sel_from == data.sel_to )
				{
					data.chars.insert( data.sel_from, event.uchar );
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from++;
					data.sel_to++;
				}
				else
				{
					from = data.sel_from;
					to = data.sel_to;
					if( from > to )
					{
						from = data.sel_to;
						to = data.sel_from;
					}
					data.chars.erase( from, to - 1 );
					data.chars.insert( from, event.uchar );
					from++;
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from = from;
					data.sel_to = from;
				}
				data.updateSelOffsets( this );
				data.resetCursorTimer( this.frame );
			}
		}
		else if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL )
			{
				data.selecting = true;
				data.sel_to = data.sel_from = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets( this );
				data.resetCursorTimer( this.frame );
			}
		}
		else if( event.type == EV_MouseMove )
		{
			if( event.button == Mouse_ButtonL && data.selecting )
			{
				data.sel_to = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets( this );
				data.resetCursorTimer( this.frame );
			}
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == Mouse_ButtonL )
				data.selecting = false;
		}
		else if( event.type == EV_KeyDown || event.type == EV_KeyUp )
		{
			key = event.key;
			mods = key & ~KeyMod_Filter;
			key &= KeyMod_Filter;
			down = event.type == EV_KeyDown;
			
			if( down )
			{
				if( key == Key_Left || key == Key_Right )
				{
					if( data.sel_from == data.sel_to || mods & KeyMod_Shift )
						data.sel_to = data.sel_to + if( key == Key_Right, 1, -1 );
					else
						data.sel_to = if( key == Key_Left, min( data.sel_from, data.sel_to ), max( data.sel_from, data.sel_to ) );
					if( !( mods & KeyMod_Shift ) )
						data.sel_from = data.sel_to;
					data.updateSelOffsets( this );
					data.resetCursorTimer( this.frame );
				}
				else if( key == Key_DelLeft || key == Key_DelRight )
				{
					if( data.sel_from != data.sel_to )
					{
						from = data.sel_from;
						to = data.sel_to;
						if( from > to )
						{
							from = data.sel_to;
							to = data.sel_from;
						}
						data.chars.erase( from, to - 1 );
						data.sel_from = from;
						data.sel_to = from;
					}
					else if( key == Key_DelLeft && data.sel_from > 0 )
					{
						data.chars.erase( data.sel_from - 1 );
						data.sel_from--;
						data.sel_to--;
					}
					else if( key == Key_DelRight && data.sel_from < data.chars.size )
					{
						data.chars.erase( data.sel_from );
					}
					data.updateText();
					this.callEvent( "change", event );
					data.updateSelOffsets( this );
					data.resetCursorTimer( this.frame );
				}
				else if( key == Key_Cut || key == Key_Copy )
				{
					if( this.frame.clipboard_func )
					{
						from = data.sel_from;
						to = data.sel_to;
						if( from > to )
						{
							from = data.sel_to;
							to = data.sel_from;
						}
						this.frame.clipboard_func( string_part( data.text, from, to - from ) );
						if( key == Key_Cut )
						{
							data.chars.erase( from, to - 1 );
							data.sel_from = from;
							data.sel_to = from;
						}
						data.updateText();
						this.callEvent( "change", event );
						data.updateSelOffsets( this );
						data.resetCursorTimer( this.frame );
					}
				}
				else if( key == Key_Paste )
				{
					if( this.frame.clipboard_func )
					{
						if( data.sel_from != data.sel_to )
						{
							from = data.sel_from;
							to = data.sel_to;
							if( from > to )
							{
								from = data.sel_to;
								to = data.sel_from;
							}
							data.chars.erase( from, to - 1 );
							data.sel_from = from;
							data.sel_to = from;
						}
						
						text = this.frame.clipboard_func();
						at = data.sel_from;
						utext = string_utf8_decode( text );
						data.chars = get_concat( data.chars.part( 0, at ), utext, data.chars.part( at ) );
						data.sel_from = data.sel_to = at + utext.size;
						data.updateText();
						this.callEvent( "change", event );
						data.updateSelOffsets( this );
						data.resetCursorTimer( this.frame );
					}
				}
				else if( key == Key_SelectAll )
				{
					data.sel_from = 0;
					data.sel_to = data.chars.size;
					data.updateSelOffsets( this );
					data.resetCursorTimer( this.frame );
				}
			}
		}
		
		return this!ocb( event );
	}
	
	function Textbox.renderfunc()
	{
		data = this.data;
		
		pad = data.padding;
		tpad = data.text_padding;
		cpad = pad + tpad;
		W = this.rx1 - this.rx0;
		H = this.ry1 - this.ry0;
		
		SS_Draw({ preset = "tile", position = vec2(this.rx0,this.ry0), scale = vec2(W,H), color = if(this.keyboardFocus,color(0.9,0.6,0.3,1),color(0.6,0.6,0.6,1)) });
		SS_Draw({ preset = "tile", position = vec2(this.rx0+pad,this.ry0+pad), scale = vec2(W-pad*2,H-pad*2), color = color(0.9,0.9,0.9,1) });
		
		x0 = this.rx0 + cpad - data.offset;
		y0 = this.ry0 + cpad;
		yc = ( this.ry0 + this.ry1 ) * 0.5;
		xh = ( H-pad*2-tpad*2 - this._cachedFont.size ) * 0.5;
		
		if( this.frame.pushScissorRect( this.rx0 + cpad, this.ry0 + cpad, this.rx1 - cpad, this.ry1 - cpad ) )
		{
			if( !data.chars && !this.keyboardFocus )
			{
				SS_DrawTextLine_VC( data.caption, this._cachedFont, x0 + xh, yc, color(0.1,0.1,0.1,0.5) );
			}
			
			SS_DrawTextLine_VC( data.text, this._cachedFont, x0, yc, color(0.1,0.1,0.1,1) );
			
			if( data.sel_to !== null )
			{
				from = min( data.fsel_from, data.fsel_to );
				to = max( data.fsel_from, data.fsel_to );
				if( from != to )
				{
					selcol = if( this.keyboardFocus, [0.3,0.6,0.9,0.5], [0.8,0.8,0.8,0.5] );
					SS_Draw({ preset = "tile", position = [x0+from,y0], scale = [to-from,H-pad*2-tpad*2], color = selcol });
				}
				
				if( this.keyboardFocus && data.show_cursor )
					SS_Draw({ preset = "tile", position = [x0+data.fsel_to,y0], scale = [1,H-pad*2-tpad*2], color = [0.1,0.1,0.1,1] });
			}
			
			this.frame.popScissorRect();
		}
	}
	
	parent.addChild( Textbox );
	
	return Textbox;
}


global UI_Slider = {};

function UI_Slider.setValue( value, event )
{
	data = this.data;
	prev = data.value;
	
	// snap the value
	if( data.stopsize )
	{
		value -= data.vmin;
		value /= data.stopsize;
		value = round( value );
		value *= data.stopsize;
		value += data.vmin;
	}
	
	// clamp it
	if( value < data.vmin ) value = data.vmin;
	if( value > data.vmax ) value = data.vmax;
	
	// apply
	data.value = value;
	if( data.vmin >= data.vmax )
		data.position = 0;
	else
		data.position = ( value - data.vmin ) / ( data.vmax - data.vmin );
	
	if( prev != value )
	{
		if( event === null )
			event = UI_CreateEvent();
		this.callEvent( "change", event );
		UIForm_CtrlChanged( this, event );
	}
}

function UI_Slider.setLimits( vmin, vmax, stopsize )
{
	stopsize ||= 0;
	data = this.data;
	data.vmin = vmin;
	data.vmax = vmax;
	data.stopsize = stopsize;
	
	this.setValue( data.value );
}

function UI_CreateSlider( parent, name, vmin, vmax, stopsize, vertical )
{
	vmin = if( vmin !== null, vmin, 0.0 );
	vmax = if( vmax !== null, vmax, 1.0 );
	
	Slider = parent.frame.createControl( "slider" );
	Slider.name = name;
	Slider._interface = UI_Slider;
	Slider.data =
	{
		mhs_x = if( !vertical, 6, 8 ), // marker half-size
		mhs_y = if( !vertical, 8, 6 ),
		border = 1,
		padding = 1,
		
		value = 0.0,
		vmin = 0.0,
		vmax = 0.0,
		stopsize = 0.0,
		position = 0.0,
		vertical = vertical,
		
		mouse_on = false,
		dragging = false,
		dragoff_x = 0,
		dragoff_y = 0,
	};
	Slider_data = Slider.data;
	function Slider_data.getValue(){ return this.value; }
	
	Slider.setLimits( vmin, vmax, stopsize );
	Slider.setValue( vmin );
	
	function Slider_data.updatePosData( Slider, dx, dy, event )
	{
		BP = this.padding + this.border;
		if( !this.vertical )
		{
			pmin = Slider.cx0 + this.mhs_x + BP;
			pmax = Slider.cx1 - this.mhs_x - BP;
			q = ( dx + this.dragoff_x - pmin ) / if( pmax > pmin + 0.0001, pmax - pmin, 0.0001 );
		}
		else
		{
			pmin = Slider.cy0 + this.mhs_y + BP;
			pmax = Slider.cy1 - this.mhs_y - BP;
			q = ( dy + this.dragoff_y - pmin ) / if( pmax > pmin + 0.0001, pmax - pmin, 0.0001 );
		}
		q = if( q < 0, 0, if( q > 1, 1, q ) );
		Slider.setValue( this.vmin * (1-q) + this.vmax * q );
	}
	function Slider_data.getMarkerPos( Slider )
	{
		pos = this.position;
		BP = this.padding + this.border;
		if( !this.vertical )
		{
			pmin = Slider.cx0 + this.mhs_x + BP;
			pmax = Slider.cx1 - this.mhs_x - BP;
			return (pmin*(1-pos) + pmax*pos), floor((Slider.cy0+Slider.cy1)*0.5);
		}
		else
		{
			pmin = Slider.cy0 + this.mhs_y + BP;
			pmax = Slider.cy1 - this.mhs_y - BP;
			return floor((Slider.cx0+Slider.cx1)*0.5), (pmin*(1-pos) + pmax*pos);
		}
	}
	function Slider_data.startDragging( Slider, cx, cy )
	{
		this.dragging = true;
		(px,py) = this.getMarkerPos( Slider );
		this.dragoff_x = px - cx;
		this.dragoff_y = py - cy;
		this.prev_position = this.position;
	}
	function Slider_data.stopDragging( Slider, event )
	{
		if( !this.dragging )
			return;
		this.dragging = false;
		if( this.prev_position != this.position )
		{
			Slider.callEvent( "commit", event );
			UIForm_CtrlChanged( Slider, event );
		}
	}
	
	ocb = Slider.callback;
	function Slider.callback( event ) use( ocb )
	{
		data = this.data;
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_MouseMove )
		{
			if( !data.dragging )
			{
				(x,y) = data.getMarkerPos( this );
				MX = data.mhs_x;
				MY = data.mhs_y;
				data.mouse_on = event.x >= x-MX && event.x <= x+MX && event.y >= y-MY && event.y <= y+MY;
			}
			else
				data.updatePosData( this, event.x, event.y, event );
		}
		else if( event.type == EV_MouseLeave )
			data.mouse_on = false;
		else if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL && data.mouse_on )
				data.startDragging( this, event.x, event.y );
		}
		else if( event.type == EV_ButtonUp )
		{
			data.stopDragging( this, event );
		}
		return this!ocb( event );
	}
	
	function Slider.renderfunc()
	{
		data = this.data;
		OFSX = data.border + data.padding + data.mhs_x - 3;
		OFSY = data.border + data.padding + data.mhs_y - 3;
		P1X = this.cx0 + OFSX;
		P1Y = this.cy0 + OFSY;
		P2X = this.cx1 - OFSX;
		P2Y = this.cy1 - OFSY;
		if( !data.vertical )
		{
			mp = round( ( P1Y + P2Y ) * 0.5 );
			P1Y = mp - 3;
			P2Y = mp + 3;
		}
		else
		{
			mp = round( ( P1X + P2X ) * 0.5 );
			P1X = mp - 3;
			P2X = mp + 3;
		}
		SS_DrawColorRect( P1X, P1Y, P2X, P2Y, 0.85, 0.85, 0.85, 1 );
		SS_DrawColorRect( P1X+1, P1Y+1, P2X-1, P2Y-1, 0.65, 0.65, 0.65, 1 );
		
		NS = if( data.stopsize, floor( ( data.vmax - data.vmin ) / data.stopsize ), 0 );
		if( NS )
		{
			vdist = data.vmax - data.vmin;
			if( vdist < 0.001 )
				vdist = 0.001;
			if( !data.vertical )
			{
				BPS = data.border + data.padding + data.mhs_x;
				SRS = this.cx0 + BPS;
				SRE = this.cx1 - BPS;
				scaled_stopsize = data.stopsize / vdist;
				if( NS * 2 < SRE - SRS )
				{
					for( q = 0; q <= 1.0; q += scaled_stopsize )
					{
						if( q > 1 )
							q = 1;
						spf = SRS * ( 1 - q ) + SRE * q;
						SS_DrawColorRect( spf, P1Y + 1, spf + 1, P2Y - 1, 0.9, 0.9, 0.9, 0.5 );
					}
				}
			}
			else
			{
				BPS = data.border + data.padding + data.mhs_y;
				SRS = this.cy0 + BPS;
				SRE = this.cy1 - BPS;
				scaled_stopsize = data.stopsize / vdist;
				if( NS * 2 < SRE - SRS )
				{
					for( q = 0; q <= 1.0; q += scaled_stopsize )
					{
						if( q > 1 )
							q = 1;
						spf = SRS * ( 1 - q ) + SRE * q;
						SS_DrawColorRect( P1X + 1, spf, P2X - 1, spf + 1, 0.9, 0.9, 0.9, 0.5 );
					}
				}
			}
		}
		
		(x,y) = data.getMarkerPos( this );
		MX = data.mhs_x;
		MY = data.mhs_y;
		mf = if( data.mouse_on, 0.1, 0.0 );
		SS_DrawColorRect( x-MX, y-MY, x+MX, y+MY, 0.6, 0.7, 0.8, 1 );
		SS_DrawColorRect( x-MX+1, y-MY+1, x+MX-1, y+MY-1, 0.3+mf, 0.5+mf, 0.7+mf, 1 );
	}
	
	parent.updateTheme();
	parent.addChild( Slider );
	return Slider;
}


global UI_SwitchButton = {};

function UI_SwitchButton.setOptions( items )
{
	data = this.data;
	data.options = items;
	// unknown interface, must count manually
	cnt = 0;
	foreach( v : items )
		cnt++;
	this.addRemClass( "no-options", cnt == 0 );
	this.addRemClass( "one-option", cnt == 1 );
	this.addRemClass( "two-options", cnt == 2 );
	this.addRemClass( "more-than-two-options", cnt > 2 );
	this.setValue( data.value );
}

function UI_SwitchButton.setValue( value, event )
{
	data = this.data;
	pvalue = data.value;
	chg = false;
	foreach( k ,: data.options )
	{
		if( k == value )
		{
			data.value = k;
			chg = true;
			break;
		}
	}
	if( !chg )
	{
		foreach( k ,: data.options )
		{
			data.value = k;
			break;
		}
	}
	if( data.value !== pvalue )
	{
		capn = data.options[ data.value ];
		if( capn === null )
			capn = data.value;
		data.btn_main.caption = capn;
		if( event === null )
			event = UI_CreateEvent();
		this.callEvent( "change", event );
		UIForm_CtrlChanged( this, event );
	}
}

function UI_SwitchButton.setPrev( event )
{
	data = this.data;
	v = data.value;
	pk = null;
	set = false;
	foreach( k ,: data.options )
	{
		if( k == v )
		{
			if( !set )
				set = true; // do not break because value will be set on last iteration
			else
				break;
		}
		pk = k;
		set = true;
	}
	this.setValue( pk, event );
}

function UI_SwitchButton.setNext( event )
{
	data = this.data;
	v = data.value;
	nk = null;
	set = false;
	tobeset = false;
	foreach( k ,: data.options )
	{
		if( tobeset )
		{
			nk = k;
			set = true;
			break;
		}
		if( k == v )
			tobeset = true;
	}
	if( tobeset && !set )
	{
		foreach( k ,: data.options )
		{
			nk = k;
			break;
		}
	}
	this.setValue( nk, event );
}

function UI_CreateSwitchButton( parent, name, options, sidebuttons, defval )
{
	sidebuttons ||= false;
	SwitchButton = parent.frame.createControl( "switchbutton" );
	SwitchButton.name = name;
	SwitchButton.data =
	{
		options = null,
		value = null,
		btn_main = null,
		btn_prev = null,
		btn_next = null,
		getValue = function SwitchButton_data_getValue(){ return this.value; },
	};
	SwitchButton._interface = UI_SwitchButton;
	SwitchButton.data.btn_main = UI_CreateButton( SwitchButton, null, null, null, null, "" ).addClass( "main-button" ).bindEvent( "click", function(){ this.parent.setNext(); } );
	if( sidebuttons )
	{
		SwitchButton.addClass( "has-side-buttons" );
		SwitchButton.data.btn_prev = UI_CreateButton( SwitchButton, null, null, null, null, "<" ).addClass( "side-button prev" ).bindEvent( "click", function(){ this.parent.setPrev(); } );
		SwitchButton.data.btn_next = UI_CreateButton( SwitchButton, null, null, null, null, ">" ).addClass( "side-button next" ).bindEvent( "click", function(){ this.parent.setNext(); } );
	}
	
	SwitchButton.setOptions( options );
	SwitchButton.setValue( defval );
	
	ocb = SwitchButton.callback;
	function SwitchButton.callback( event ) use( ocb )
	{
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonDown && event.button != 0 )
		{
			this.frame.setFocus( this );
			return;
		}
		return this!ocb( event );
	}
	
	SwitchButton.updateTheme();
	parent.addChild( SwitchButton );
	return SwitchButton;
}


global UI_SelectBox = {};
function UI_SelectBox.setItems( items )
{
	// validate items
	foreach( item : items )
	{
		if( typeof( item ) != "string" && typeof( @item.text ) != "string" )
			return WARNING( "item must be string or { text, value } dict" );
	}
	// overwrite item array
	data = this.data;
	data.items.clear();
	foreach( item : items )
	{
		oitem =
		{
			text = @item.text || item,
			value = @item.value || @item.text || item,
			group = @item.group,
		};
		data.items.push( oitem );
	}
	
	this.selectItem( 0 );
}
function UI_SelectBox.selectItem( id, event )
{
	id = parseint( id );
	if( id === null )
		return WARNING( "ID must be an integer" );
	
	data = this.data;
	if( id < 0 || id >= data.items.size )
		id = 0;
	if( data.items.size )
	{
		this.caption = data.items[ id ].text;
		data.selectedIndex = id;
		data.selectedValue = data.items[ id ].value;
	}
	else
	{
		this.caption = "";
		data.selectedIndex = -1;
		data.selectedValue = null;
	}
	this.callEvent( "change", event );
}

function UI_CreateSelectBox( parent, name, items )
{
	SelectBox = parent.frame.createControl( "selectbox" );
	SelectBox._interface = UI_SelectBox;
	SelectBox.data =
	{
		items = [],
		icon = SS_CreateTexture( "icons/bullet_arrow_down.png" ),
	};
	SelectBox.name = name;
	
	orig_callback = SelectBox.callback;
	SelectBoxData = SelectBox.data;
	
	function SelectBoxData.getValue(){ return this.selectedValue; }
	
	function SelectBox.callback( event ) use( orig_callback )
	{
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonDown && event.button != 0 )
		{
			this.frame.setFocus( this );
			return;
		}
		return this!orig_callback( event );
	}
	
	function SelectBox.renderfunc()
	{
		if( this.rx0 == this.rx1 || this.ry0 == this.ry1 )
			return;
		
		data = this.data;
		icon = data.icon;
		text = this.caption;
		
		cadd = if( this.clicked, -0.02, if( this.mouseOn, 0.02, 0.0 ) );
		SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.6+cadd, 0.6+cadd, 0.6+cadd, 1 );
		SS_DrawColorRect( this.rx0+1, this.ry0+1, this.rx1-1, this.ry1-1, 0.8+cadd, 0.8+cadd, 0.8+cadd, 1 );
		
		if( this.frame.pushScissorRect( this.rx0 + 2, this.ry0 + 2, this.rx1 - 2, this.ry1 - 2 ) )
		{
			fullwidth = 0;
			if( text )
			{
				textlen = this._cachedFont.getTextLength( text );
				fullwidth += textlen;
			}
			
			cy = round( ( this.ry1 + this.ry0 ) * 0.5 );
			if( icon )
			{
				SS_Draw({ preset = "box", position = vec2( this.rx1 - icon.width, cy ), scale = vec2( icon.width, icon.height ), texture = icon });
			}
			
			if( text )
			{
				SS_DrawTextLine_VC( text, this._cachedFont, this.rx0 + 4, cy, color(0,1) );
			}
			
			this.frame.popScissorRect();
		}
	}
	
	SelectBox.setItems( items );
	
	parent.addChild( SelectBox );
	
	return SelectBox;
}

