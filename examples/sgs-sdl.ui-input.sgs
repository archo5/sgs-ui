

global UI_Form = {};
function UI_Form.getData(){ return this.data.getData(); }
function UI_Form.getList( name ){ return this.data.getList( name ); }
function UI_Form.getString( name ){ return this.data.getString( name ); }

function UI_CreateForm( parent )
{
	Form = parent.frame.createControl( "form" );
	Form.data = { ctrls = map() };
	Form.q1x = 1;
	Form.q1y = 1;
	
	Form._interface = UI_Form;
	
	Form_data = Form.data;
	function Form_data.getData()
	{
		out = {};
		foreach( ctrl ,: this.ctrls )
		{
			val = ctrl.data.getValue();
			if( val !== null )
			{
				if( isset( out, ctrl.name ) )
					out[ ctrl.name ].push( val );
				else
					out[ ctrl.name ] = [ val ];
			}
			else
			{
				if( !isset( out, ctrl.name ) )
					out[ ctrl.name ] = [];
			}
		}
		return out;
	}
	function Form_data.getList( name )
	{
		out = [];
		foreach( ctrl ,: this.ctrls )
		{
			if( ctrl.name == name )
			{
				val = ctrl.data.getValue();
				if( val !== null )
				{
					if( typeof(val) !== "array" )
						out.push( val );
					else
						out = get_concat( out, val );
				}
			}
		}
		return out;
	}
	function Form_data.getString( name )
	{
		foreach( ctrl ,: this.ctrls )
		{
			if( ctrl.name == name )
			{
				val = ctrl.data.getValue();
				if( val !== null )
					return val;
			}
		}
		return null;
	}
	
	parent.addChild( Form );
	
	return Form;
}

function form_get_from_ctrl( ctrl )
{
	while( ctrl )
	{
		if( ctrl.type == "form" )
			return ctrl;
		ctrl = ctrl.parent;
	}
	return null;
}

function form_change_event( form, event )
{
	form.callEvent( "change", event );
}

function UIForm_Attach( ctrl, event )
{
	form = form_get_from_ctrl( ctrl );
	if( form )
	{
		form.data.ctrls[ ctrl ] = true;
		form_change_event( form, event );
	}
}

function UIForm_Detach( ctrl, event )
{
	form = form_get_from_ctrl( ctrl );
	if( form )
	{
		unset( form.data.ctrls, ctrl );
		form_change_event( form, event );
	}
}

function form_ctrl_changed( ctrl, event )
{
	form = form_get_from_ctrl( ctrl );
	if( form )
		form_change_event( form, event );
}

function form_controls_by_name( ctrl, name )
{
	form = form_get_from_ctrl( ctrl );
	if( form )
	{
		out = [];
		foreach( c ,: form.data.ctrls )
		{
			if( c.name == name )
				out.push( c );
		}
		return out;
	}
	return [];
}


function UI_CreateCheckbox( parent, x, y, width, height, name, value, checked )
{
	cb_size = 16;
	
	Checkbox = parent.frame.createControl( "checkbox" );
	x = round( x + width / 2 );
	y = round( y + width / 2 );
	Checkbox.x = x - round( cb_size / 2 );
	Checkbox.y = y - round( cb_size / 2 );
	Checkbox.width = cb_size;
	Checkbox.height = cb_size;
	Checkbox.name = name;
	Checkbox.data =
	{
		border = 1,
		padding = 2,
		
		checked = checked || false,
		value = if( value === null, 1, value ),
	};
	
	cbdata = Checkbox.data;
	
	function cbdata.getValue(){ return if( this.checked, this.value, null ); };
	
	orig_callback = Checkbox.callback;
	function Checkbox.callback( event ) use( orig_callback )
	{
		data = this.data;
		
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == 0 && this.clicked && this.mouseOn )
			{
				data.checked = !data.checked;
				this.callEvent( "change", event );
				form_ctrl_changed( this, event );
			}
		}
		return this!orig_callback( event );
	}
	
	function Checkbox.renderfunc()
	{
		data = this.data;
		
		p1 = data.border;
		p2 = data.padding + p1;
		
		SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.5, 0.6, 0.8, 1 );
		
		if( this.clicked )
			SS_DrawColorRect( this.rx0 + p1, this.ry0 + p1, this.rx1 - p1, this.ry1 - p1, 0.8, 0.8, 0.8, 1 );
		else
			SS_DrawColorRect( this.rx0 + p1, this.ry0 + p1, this.rx1 - p1, this.ry1 - p1, 0.9, 0.9, 0.9, 1 );
		
		if( data.checked )
			SS_DrawColorRect( this.rx0 + p2, this.ry0 + p2, this.rx1 - p2, this.ry1 - p2, 0.1, 0.2, 0.4, 1 );
	}
	
	parent.addChild( Checkbox );
	
	return Checkbox;
}

function UI_CreateRadioButton( parent, x, y, width, height, name, value, checked )
{
	cb_size = 16;
	
	RadioBtn = parent.frame.createControl( "radiobtn" );
	x = round( x + width / 2 );
	y = round( y + width / 2 );
	RadioBtn.x = x - round( cb_size / 2 );
	RadioBtn.y = y - round( cb_size / 2 );
	RadioBtn.width = cb_size;
	RadioBtn.height = cb_size;
	RadioBtn.name = name;
	RadioBtn.data =
	{
		border = 1,
		padding = 2,
		
		checked = checked || false,
		value = if( value === null, 1, value ),
	};
	
	rbdata = RadioBtn.data;
	
	function rbdata.getValue(){ return if( this.checked, this.value, null ); };
	
	orig_callback = RadioBtn.callback;
	function RadioBtn.callback( event ) use( orig_callback )
	{
		data = this.data;
		
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == 0 && this.clicked && this.mouseOn )
			{
				ctrls = form_controls_by_name( this, this.name );
				foreach( ctrl : ctrls )
				{
					if( ctrl.type == "radiobtn" && ctrl != this )
					{
						if( ctrl.data.checked != false )
						{
							ctrl.data.checked = false;
							ctrl.callEvent( "change", event );
							form_ctrl_changed( this, event );
						}
					}
				}
				if( data.checked != true )
				{
					data.checked = true;
					this.callEvent( "change", event );
					form_ctrl_changed( this, event );
				}
			}
		}
		return this!orig_callback( event );
	}
	
	function RadioBtn.renderfunc()
	{
		data = this.data;
		
		p1 = data.border;
		p2 = data.padding + p1;
		
		cx = ( this.rx0 + this.rx1 ) / 2;
		cy = ( this.ry0 + this.ry1 ) / 2;
		radius = round( min( this.rx1 - this.rx0, this.ry1 - this.ry0 ) / 2 );
		
		draw_color_circle( cx, cy, radius, null, 0.5, 0.6, 0.8, 1 );
		
		if( this.clicked )
			draw_color_circle( cx, cy, radius - p1, null, 0.8, 0.8, 0.8, 1 );
		else
			draw_color_circle( cx, cy, radius - p1, null, 0.9, 0.9, 0.9, 1 );
		
		if( data.checked )
			draw_color_circle( cx, cy, radius - p2, null, 0.1, 0.2, 0.4, 1 );
	}
	
	parent.addChild( RadioBtn );
	
	return RadioBtn;
}


function UI_CreateTextbox( parent, x, y, width, caption, text )
{
	caption ||= "";
	text ||= "";
	
	Textbox = parent.frame.createControl( "textbox" );
	Textbox.x = x;
	Textbox.y = y;
	Textbox.width = width;
	
	Textbox.data =
	{
		padding = 1,
		text_padding = 2,
		height = 24,
		caption = caption,
		
		offset = 0,
		sel_from = text.length,
		sel_to = text.length,
		fsel_from = null,
		fsel_to = null,
		selecting = false,
		chars = string_utf8_decode( text ),
		text = text,
		prevtext = text,
		show_cursor = true,
		cursor_timer = null,
	};
	
	tbdata = Textbox.data;
	
	function tbdata.getValue(){ return this.text; }
	
	function tbdata.removeCursorTimer( frame )
	{
		if( this.cursor_timer )
			frame.clearInterval( this.cursor_timer );
		this.cursor_timer = null;
	}
	function tbdata.resetCursorTimer( frame )
	{
		tbdata = this;
		this.removeCursorTimer( frame );
		this.cursor_timer = frame.setInterval( 0.5, function() use( tbdata ) { tbdata.show_cursor = !tbdata.show_cursor; } );
		this.show_cursor = true;
	}
	
	function tbdata.updateSelOffsets()
	{
		this.sel_from = max( 0, min( this.sel_from, this.chars.size ) );
		this.sel_to = max( 0, min( this.sel_to, this.chars.size ) );
		this.fsel_to = 0;
		this.fsel_from = 0;
		
		pc = null;
		for( i = 0; i < this.sel_from; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_from += Font.getAdvance( pc, ch );
			pc = ch;
		}
		
		pc = null;
		for( i = 0; i < this.sel_to; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_to += Font.getAdvance( pc, ch );
			pc = ch;
		}
	}
	
	function tbdata.updateText()
	{
		this.text = string_utf8_encode( this.chars );
	}
	
	function tbdata.findOffset( ctrl, x, y )
	{
		cpad = this.padding + this.text_padding;
		x -= ctrl.rx0 + cpad - this.offset;
		y -= ctrl.ry0 + cpad;
		
		fmin = 0.0;
		fmax = 0.0;
		pc = null;
		for( i = 0; i < this.chars.size; ++i )
		{
			ch = this.chars[ i ];
			fmax += Font.getAdvance( pc, ch );
			if( x <= (fmin+fmax)*0.5 )
				break;
			fmin = fmax;
			pc = ch;
		}
		return i;
	}
	
	tbdata.updateSelOffsets();
	
	ocb = Textbox.callback;
	function Textbox.callback( event ) use( ocb )
	{
		data = this.data;
		
		if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
			data.removeCursorTimer( this.frame );
		}
		else if( event.type == EV_Layout )
		{
			this.height = data.height;
		}
		else if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_FocusEnter )
		{
			data.prevtext = data.text;
			data.resetCursorTimer( this.frame );
		}
		else if( event.type == EV_FocusLeave )
		{
			data.removeCursorTimer( this.frame );
			if( data.prevtext != data.text )
			{
				this.callEvent( "commit", event );
				form_ctrl_changed( this, event );
			}
		}
		else if( event.type == EV_Char )
		{
			if( event.uchar > 0x1f && event.uchar != 0x7f )
			{
				if( data.sel_from == data.sel_to )
				{
					data.chars.insert( data.sel_from, event.uchar );
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from++;
					data.sel_to++;
				}
				else
				{
					from = data.sel_from;
					to = data.sel_to;
					if( from > to )
					{
						from = data.sel_to;
						to = data.sel_from;
					}
					data.chars.erase( from, to - 1 );
					data.chars.insert( from, event.uchar );
					from++;
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from = from;
					data.sel_to = from;
				}
				data.updateSelOffsets();
				data.resetCursorTimer( this.frame );
			}
		}
		else if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL )
			{
				data.selecting = true;
				data.sel_to = data.sel_from = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets();
				data.resetCursorTimer( this.frame );
			}
		}
		else if( event.type == EV_MouseMove )
		{
			if( event.button == Mouse_ButtonL && data.selecting )
			{
				data.sel_to = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets();
				data.resetCursorTimer( this.frame );
			}
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == Mouse_ButtonL )
				data.selecting = false;
		}
		else if( event.type == EV_KeyDown || event.type == EV_KeyUp )
		{
			key = event.key;
			mods = key & ~KeyMod_Filter;
			key &= KeyMod_Filter;
			down = event.type == EV_KeyDown;
			
			if( down )
			{
				if( key == Key_Left || key == Key_Right )
				{
					if( data.sel_from == data.sel_to || mods & KeyMod_Shift )
						data.sel_to = data.sel_to + if( key == Key_Right, 1, -1 );
					else
						data.sel_to = if( key == Key_Left, min( data.sel_from, data.sel_to ), max( data.sel_from, data.sel_to ) );
					if( !( mods & KeyMod_Shift ) )
						data.sel_from = data.sel_to;
					data.updateSelOffsets();
					data.resetCursorTimer( this.frame );
				}
				else if( key == Key_DelLeft || key == Key_DelRight )
				{
					if( data.sel_from != data.sel_to )
					{
						from = data.sel_from;
						to = data.sel_to;
						if( from > to )
						{
							from = data.sel_to;
							to = data.sel_from;
						}
						data.chars.erase( from, to - 1 );
						data.sel_from = from;
						data.sel_to = from;
					}
					else if( key == Key_DelLeft && data.sel_from > 0 )
					{
						data.chars.erase( data.sel_from - 1 );
						data.sel_from--;
						data.sel_to--;
					}
					else if( key == Key_DelRight && data.sel_from < data.chars.size )
					{
						data.chars.erase( data.sel_from );
					}
					data.updateText();
					this.callEvent( "change", event );
					data.updateSelOffsets();
					data.resetCursorTimer( this.frame );
				}
				else if( key == Key_Cut || key == Key_Copy )
				{
					if( this.frame.clipboard_func )
					{
						from = data.sel_from;
						to = data.sel_to;
						if( from > to )
						{
							from = data.sel_to;
							to = data.sel_from;
						}
						this.frame.clipboard_func( string_part( data.text, from, to - from ) );
						if( key == Key_Cut )
						{
							data.chars.erase( from, to - 1 );
							data.sel_from = from;
							data.sel_to = from;
						}
						data.updateText();
						this.callEvent( "change", event );
						data.updateSelOffsets();
						data.resetCursorTimer( this.frame );
					}
				}
				else if( key == Key_Paste )
				{
					if( this.frame.clipboard_func )
					{
						if( data.sel_from != data.sel_to )
						{
							from = data.sel_from;
							to = data.sel_to;
							if( from > to )
							{
								from = data.sel_to;
								to = data.sel_from;
							}
							data.chars.erase( from, to - 1 );
							data.sel_from = from;
							data.sel_to = from;
						}
						
						text = this.frame.clipboard_func();
						at = data.sel_from;
						utext = string_utf8_decode( text );
						data.chars = get_concat( data.chars.part( 0, at ), utext, data.chars.part( at ) );
						data.sel_from = data.sel_to = at + utext.size;
						data.updateText();
						this.callEvent( "change", event );
						data.updateSelOffsets();
						data.resetCursorTimer( this.frame );
					}
				}
				else if( key == Key_SelectAll )
				{
					data.sel_from = 0;
					data.sel_to = data.chars.size;
					data.updateSelOffsets();
					data.resetCursorTimer( this.frame );
				}
			}
		}
		
		return this!ocb( event );
	}
	
	function Textbox.renderfunc()
	{
		data = this.data;
		
		pad = data.padding;
		tpad = data.text_padding;
		cpad = pad + tpad;
		
		SS_Draw({ preset = "tile", position = vec2(this.rx0,this.ry0), scale = vec2(this.width,this.height), color = if(this.keyboardFocus,color(0.9,0.6,0.3,1),color(0.6,0.6,0.6,1)) });
		SS_Draw({ preset = "tile", position = vec2(this.rx0+pad,this.ry0+pad), scale = vec2(this.width-pad*2,this.height-pad*2), color = color(0.9,0.9,0.9,1) });
		
		x0 = this.rx0 + cpad - data.offset;
		y0 = this.ry0 + cpad;
		yc = ( this.ry0 + this.ry1 ) * 0.5;
		xh = ( this.height-pad*2-tpad*2 - Font.size ) * 0.5;
		
		if( this.frame.pushScissorRect( this.rx0 + cpad, this.ry0 + cpad, this.rx1 - cpad, this.ry1 - cpad ) )
		{
			if( !data.chars && !this.keyboardFocus )
			{
				SS_DrawTextLine_VC( data.caption, Font, x0 + xh, yc, color(0.1,0.1,0.1,0.5) );
			}
			
			SS_DrawTextLine_VC( data.text, Font, x0, yc, color(0.1,0.1,0.1,1) );
			
			if( data.sel_to !== null )
			{
				from = min( data.fsel_from, data.fsel_to );
				to = max( data.fsel_from, data.fsel_to );
				if( from != to )
				{
					selcol = if( this.keyboardFocus, [0.3,0.6,0.9,0.5], [0.8,0.8,0.8,0.5] );
					SS_Draw({ preset = "tile", position = [x0+from,y0], scale = [to-from,this.height-pad*2-tpad*2], color = selcol });
				}
				
				if( this.keyboardFocus && data.show_cursor )
					SS_Draw({ preset = "tile", position = [x0+data.fsel_to,y0], scale = [1,this.height-pad*2-tpad*2], color = [0.1,0.1,0.1,1] });
			}
			
			this.frame.popScissorRect();
		}
	}
	
	parent.addChild( Textbox );
	
	return Textbox;
}


global UI_Slider = {};

function UI_Slider.setNumStops( num )
{
	num = toint( num );
	if( num == 0 || num >= 2 )
	{
		this.data.numstops = num;
		return true;
	}
	return false;
}

function UI_CreateSlider( parent, x, y, width, height, name, numstops, vertical )
{
	Slider = parent.frame.createControl( "slider" );
	Slider.x = x;
	Slider.y = y;
	Slider.width = width;
	Slider.height = height;
	Slider.name = name;
	Slider._interface = UI_Slider;
	Slider.data =
	{
		mhs_x = 6, // marker half-size
		mhs_y = 8,
		
		numstops = toint( numstops ) || 0,
		whichstop = 0,
		position = 0,
		vertical = vertical,
		
		dragging = false,
		dragoff_x = 0,
		dragoff_y = 0,
	};
	Slider_data = Slider.data;
	function Slider_data.getValue(){ return if( this.numstops, this.whichstop, this.position ); }
	
	function Slider_data.updatePosData( Slider, dx, dy )
	{
	}
	function Slider_data.getMarkerPos( Slider )
	{
		pos = if( this.numstops, this.whichstop / ( this.numstops - 1 ), this.position );
	}
	function Slider_data.startDragging( Slider, cx, cy )
	{
		this.dragging = true;
	}
	
	ocb = Slider.callback;
	function Slider.callback( event ) use( ocb )
	{
	}
	
	function Slider.renderfunc()
	{
	}
	
	parent.addChild( Slider );
	
	return Slider;
}


global UI_SelectBox = {};
function UI_SelectBox.setItems( items )
{
	// validate items
	foreach( item : items )
	{
		if( typeof( item ) != "string" && typeof( @item.text ) != "string" )
			return WARNING( "item must be string or { text, value } dict" );
	}
	// overwrite item array
	data = this.data;
	data.items.clear();
	foreach( item : items )
	{
		oitem =
		{
			text = @item.text || item,
			value = @item.value || @item.text || item,
			group = @item.group,
		};
		data.items.push( oitem );
	}
	
	this.selectItem( 0 );
}
function UI_SelectBox.selectItem( id, event )
{
	id = parseint( id );
	if( id === null )
		return WARNING( "ID must be an integer" );
	
	data = this.data;
	if( id < 0 || id >= data.items.size )
		id = 0;
	if( data.items.size )
	{
		this.caption = data.items[ id ].text;
		data.selectedIndex = id;
		data.selectedValue = data.items[ id ].value;
	}
	else
	{
		this.caption = "";
		data.selectedIndex = -1;
		data.selectedValue = null;
	}
	this.callEvent( "change", event );
}

function UI_CreateSelectBox( parent, x, y, width, height, name, items )
{
	SelectBox = parent.frame.createControl( "selectbox" );
	SelectBox._interface = UI_SelectBox;
	SelectBox.data =
	{
		items = [],
		icon = SS_CreateTexture( "icons/bullet_arrow_down.png" ),
	};
	SelectBox.x = x;
	SelectBox.y = y;
	SelectBox.width = width;
	SelectBox.height = height;
	SelectBox.name = name;
	
	orig_callback = SelectBox.callback;
	SelectBoxData = SelectBox.data;
	
	function SelectBoxData.getValue(){ return this.selectedValue; }
	
	function SelectBox.callback( event ) use( orig_callback )
	{
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			UIForm_Attach( this, event );
		}
		else if( event.type == EV_Detach )
		{
			UIForm_Detach( this, event );
		}
		else if( event.type == EV_ButtonDown && event.button != 0 )
		{
			this.frame.setFocus( this );
			return;
		}
		return this!orig_callback( event );
	}
	
	function SelectBox.renderfunc()
	{
		if( this.rx0 == this.rx1 || this.ry0 == this.ry1 )
			return;
		
		data = this.data;
		icon = data.icon;
		text = this.caption;
		
		cadd = if( this.clicked, -0.02, if( this.mouseOn, 0.02, 0.0 ) );
		SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.6+cadd, 0.6+cadd, 0.6+cadd, 1 );
		SS_DrawColorRect( this.rx0+1, this.ry0+1, this.rx1-1, this.ry1-1, 0.8+cadd, 0.8+cadd, 0.8+cadd, 1 );
		
		if( this.frame.pushScissorRect( this.rx0 + 2, this.ry0 + 2, this.rx1 - 2, this.ry1 - 2 ) )
		{
			fullwidth = 0;
			if( text )
			{
				textlen = Font.getTextLength( text );
				fullwidth += textlen;
			}
			
			cy = round( ( this.ry1 + this.ry0 ) * 0.5 );
			if( icon )
			{
				SS_Draw({ preset = "box", position = vec2( this.rx1 - icon.width, cy ), scale = vec2( icon.width, icon.height ), texture = icon });
			}
			
			if( text )
			{
				SS_DrawTextLine_VC( text, Font, this.rx0 + 4, cy, color(0,1) );
			}
			
			this.frame.popScissorRect();
		}
	}
	
	SelectBox.setItems( items );
	
	parent.addChild( SelectBox );
	
	return SelectBox;
}

