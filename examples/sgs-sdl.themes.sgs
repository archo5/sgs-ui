
global SS_UI_Theme_Default =
{
	stylesheet = UI_BuildStyleSheet
	({
		"" = { fontSize = 11 },
		"static" =
		{
			textColor = UIColor( 0.1, 1 ),
			backgroundColor = UIColor( 0.5, 1 ),
			renderfunc = function SS_UI_Theme_Default_static_renderfunc()
			{
				data = this.data;
				text = this.caption;
				
				c = this.backgroundColor;
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, c.r, c.g, c.b, c.a );
				
				if( text )
				{
					SS_DrawTextRect( text, this._cachedFont, SS_UI_ConvertColor( this.textColor ), data.textmode, this.px0, this.px1, this.py0, this.py1 );
				}
			}
		},
		"button" =
		{
			renderfunc = function SS_UI_Theme_Default_button_renderfunc()
			{
				if( this.rx0 == this.rx1 || this.ry0 == this.ry1 )
					return;
				theme = this.frame.theme;
				button_render_bgr = theme.button_render_bgr;
				button_render_contents = theme.button_render_contents;
				this!button_render_bgr();
				this!button_render_contents();
			}
		},
		"image" =
		{
			renderfunc = function Image.renderfunc()
			{
				data = this.data;
				scale = data.scale;
				
				W = this.rx1 - this.rx0;
				H = this.ry1 - this.ry0;
				IW = data.image.width;
				IH = data.image.height;
				IW = if( IW >= 1, IW, 1 );
				IH = if( IH >= 1, IH, 1 );
				
				if( scale === UI_ImageScale_Stretch )
				{
					xscale = W / IW;
					yscale = H / IH;
				}
				else if( scale === UI_ImageScale_Crop )
				{
					xscale = W / IW;
					yscale = H / IH;
					if( xscale > yscale )
						yscale = xscale;
					else
						xscale = yscale;
				}
				else if( scale === UI_ImageScale_Fit )
				{
					xscale = W / IW;
					yscale = H / IH;
					if( xscale > yscale )
						xscale = yscale;
					else
						yscale = xscale;
				}
				else
				{
					xscale = scale;
					yscale = scale;
				}
				
				realsize_x = round( IW * xscale );
				realsize_y = round( IH * yscale );
				
				off_x = round( ( W - realsize_x ) * data.align_x );
				off_y = round( ( H - realsize_y ) * data.align_y );
				
				if( this.frame.pushScissorRect( this.rx0, this.ry0, this.rx1, this.ry1 ) )
				{
					X = this.rx0 + off_x;
					Y = this.ry0 + off_y;
					SS_Draw({ preset = "tile", texture = data.image, position = vec2(X,Y), scale = vec2(realsize_x,realsize_y) });
					
					this.frame.popScissorRect();
				}
			}
		},
		"form" = { anchorMode = UI_Anchor_All },
		"checkbox" =
		{
			minWidth = 16,
			minHeight = 16,
			maxWidth = 16,
			maxHeight = 16,
			renderfunc = function SS_UI_Theme_Default_checkbox_renderfunc()
			{
				data = this.data;
				
				theme = this.frame.theme;
				p1 = theme.checkbox_border;
				p2 = theme.checkbox_padding + p1;
				
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.5, 0.6, 0.8, 1 );
				
				if( this.clicked )
					SS_DrawColorRect( this.rx0 + p1, this.ry0 + p1, this.rx1 - p1, this.ry1 - p1, 0.8, 0.8, 0.8, 1 );
				else
					SS_DrawColorRect( this.rx0 + p1, this.ry0 + p1, this.rx1 - p1, this.ry1 - p1, 0.9, 0.9, 0.9, 1 );
				
				if( data.checked )
					SS_DrawColorRect( this.rx0 + p2, this.ry0 + p2, this.rx1 - p2, this.ry1 - p2, 0.1, 0.2, 0.4, 1 );
			}
		},
		"radiobutton" =
		{
			minWidth = 16,
			minHeight = 16,
			maxWidth = 16,
			maxHeight = 16,
			renderfunc = function SS_UI_Theme_Default_radiobtn_renderfunc()
			{
				data = this.data;
				
				theme = this.frame.theme;
				p1 = theme.radiobtn_border;
				p2 = theme.radiobtn_padding + p1;
				
				cx = ( this.rx0 + this.rx1 ) / 2;
				cy = ( this.ry0 + this.ry1 ) / 2;
				radius = round( min( this.rx1 - this.rx0, this.ry1 - this.ry0 ) / 2 );
				
				SS_DrawColorCircle( cx, cy, radius, null, 0.5, 0.6, 0.8, 1 );
				
				if( this.clicked )
					SS_DrawColorCircle( cx, cy, radius - p1, null, 0.8, 0.8, 0.8, 1 );
				else
					SS_DrawColorCircle( cx, cy, radius - p1, null, 0.9, 0.9, 0.9, 1 );
				
				if( data.checked )
					SS_DrawColorCircle( cx, cy, radius - p2, null, 0.1, 0.2, 0.4, 1 );
			}
		},
		"switchbutton button" = { height = 0 },
		"switchbutton .main-button" = { anchorMode = UI_Anchor_All, width = 0 },
		"switchbutton .side-button.prev" = { anchorMode = UI_Anchor_Vert | UI_Anchor_Left, x = 0, width = 24 },
		"switchbutton .side-button.next" = { anchorMode = UI_Anchor_Vert | UI_Anchor_Right, x = -24, width = 24 },
		"switchbutton.has-side-buttons .main-button" = { x = 24, width = -48 },
		"scrollbar" =
		{
			padding = 1,
			renderfunc = function SS_UI_Theme_Default_scroll_renderfunc()
			{
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.8, 0.8, 0.8, 1 );
				SS_DrawColorRect( this.px0, this.py0, this.px1, this.py1, 0.7, 0.7, 0.7, 1 );
			}
		},
		"menu" =
		{
			renderfunc = function SS_UI_Theme_Default_menu_renderfunc()
			{
				data = this.data;
				
				pad = data.menu_padding;
				
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.8, 0.8, 0.8, 1 );
				SS_DrawColorRect( this.rx0+pad, this.ry0+pad, this.rx1-pad, this.ry1-pad, 0.9, 0.9, 0.9, 1 );
				
				SS_DrawColorRect( this.rx0+32, this.ry0+2+pad, this.rx0+33, this.ry1-2-pad, 0.8, 0.8, 0.8, 1 );
				
				x = this.rx0 + pad;
				y = this.ry0 + pad;
				foreach( id, item : data.items )
				{
					disabled = @item.disabled;
					checked = @item.checked;
					
					if( id === data.selected )
						SS_Draw({ preset = "tile", position = [x,y], scale = [data.item_width,data.item_height], color = if(disabled,[0.7,0.7,0.7,0.5],[0.4,0.6,0.8,0.8]) });
					
					if( isset( item, "menu" ) )
						SS_DrawFitted( data.icon_submenu, x + data.item_width - data.item_height, x + data.item_width, y, y + data.item_height );
					
					if( @item.text !== null )
						SS_DrawTextLine_VC( item.text, this._cachedFont, x + 32, y + data.item_height / 2, if(disabled,[0.5,0.5,0.5,1],[0.1,0.1,0.1,1]) );
					else if( disabled )
						SS_Draw({ preset = "tile", position = [x+32,y+data.sep_height/2], scale = [data.item_width-36,1], color = [0.8,0.8,0.8,1] });
					
					if( disabled && @item.text === null )
						y += data.sep_height;
					else
					{
						if( checked !== null )
						{
							// checkbox
							cbx0 = x + 4;
							cby0 = y + 4;
							cbsz = min( 24, data.item_height - 8 );
							cbx1 = cbx0 + cbsz;
							cby1 = cby0 + cbsz;
							SS_DrawColorRect( cbx0, cby0, cbx1, cby1, 0.5, 0.6, 0.7, 1 );
							SS_DrawColorRect( cbx0+1, cby0+1, cbx1-1, cby1-1, 0.9, 0.9, 0.9, 1 );
							if( checked )
								SS_DrawColorRect( cbx0+3, cby0+3, cbx1-3, cby1-3, 0.1, 0.2, 0.4, 1 );
						}
						y += data.item_height;
					}
					y += data.item_spacing;
				}
			}
		},
		"scrollable" =
		{
			backgroundColor = UIColor( 0.8, 1 ),
			renderfunc = function SS_UI_Theme_Default_scrollable_renderfunc()
			{
				c = this.backgroundColor;
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, c.r-0.2, c.g-0.2, c.b-0.2, c.a );
				SS_DrawColorRect( this.cx0, this.cy0, this.cx1, this.cy1, c.r, c.g, c.b, c.a );
			}
		},
		"menupanel" =
		{
			anchorMode = UI_Anchor_All,
			renderfunc = function SS_UI_Theme_Default_menupanel_renderfunc()
			{
				data = this.data;
				iht = data.item_height;
				
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.cy0, 0.9, 0.9, 0.9, 1 );
				
				foreach( i, item : data.items )
				{
					disabled = @item.disabled;
					
					if( data.selected === i )
					{
						if( disabled )
						{
							SS_DrawColorRect( item.x, item.y, item.x + item.width, item.y + iht, 0.5, 0.5, 0.5, 1 );
							SS_DrawColorRect( item.x+1, item.y+1, item.x + item.width-1, item.y + iht-1, 0.8, 0.8, 0.8, 1 );
						}
						else
						{
							SS_DrawColorRect( item.x, item.y, item.x + item.width, item.y + iht, 0.4, 0.5, 0.6, 1 );
							SS_DrawColorRect( item.x+1, item.y+1, item.x + item.width-1, item.y + iht-1, 0.7, 0.8, 0.9, 1 );
						}
					}
					
					col = if( disabled, [0.5,0.5,0.5,1], [0.1,0.1,0.1,1] );
					SS_DrawTextLine_VC( item.text, this._cachedFont, item.x + data.side_padding, item.y + iht / 2, col );
				}
			}
		},
		"scrollingautolayout scrollable" = { anchorMode = UI_Anchor_All },
		"scrollingautolayout autolayout" = { anchorMode = UI_Anchor_Hor | UI_Anchor_Top },
		"listboxmenu scrollable" = { anchorMode = UI_Anchor_All },
		"listboxmenu autolayout" = { anchorMode = UI_Anchor_Hor | UI_Anchor_Top },
		"listboxmenu autolayout button" =
		{
			height = 24,
			q1x = 1,
			renderfunc = function SS_UI_Theme_Default_listboxmenu_button_renderfunc()
			{
				if( this.rx0 >= this.rx1 || this.ry0 >= this.ry1 )
					return;
				
				data = this.data;
				icon = @data.icon;
				text = this.caption;
				
				caddt = if( this.clicked, 0.02, if( this.mouseOn, -0.05, 0.0 ) );
				caddb = if( this.clicked, 0.09, if( this.mouseOn, 0.05, 0.0 ) );
				SS_DrawColor2VRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.4-caddt, 0.6-caddt, 0.8-caddt, 1, 0.4+caddb, 0.5+caddb, 0.6+caddb, 1 );
				
				if( this.frame.pushScissorRect( this.rx0 + 2, this.ry0 + 2, this.rx1 - 2, this.ry1 - 2 ) )
				{
					cy = round( ( this.ry1 + this.ry0 ) * 0.5 );
					if( icon )
					{
						SS_Draw({ preset = "box", position = vec2( this.rx1 - round( 4 + icon.width / 2 ), cy ), scale = vec2( icon.width, icon.height ), texture = icon });
					}
					
					if( text )
					{
						SS_DrawTextLine_VC( text, this._cachedFont, this.rx0 + 4, cy, color(1,1,1,1) );
					}
					
					this.frame.popScissorRect();
				}
			}
		},
		"propertygrid scrollable" = { anchorMode = UI_Anchor_All },
		"propertygrid autolayout" = { anchorMode = UI_Anchor_Hor | UI_Anchor_Top },
		"propertygrid .label" = { q1x = 0.5, height = 24, backgroundColor = UIColor(0,0.1) },
		"propertygrid .value" = { q1x = 0.5, height = 24 },
		"propertygrid button.value" = { q1x = 1 },
		"window" =
		{
			nonClientTop = 24,
			nonClientBottom = 4,
			nonClientLeft = 4,
			nonClientRight = 4,
			renderfunc = function SS_UI_Theme_Default_window_renderfunc()
			{
				SS_DrawColorRect( this.rx0 + 2, this.ry0 + 2, this.rx1 + 2, this.ry1 + 2, 0.0, 0.0, 0.0, 0.2 );
				SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.4, 0.6, 0.8, 1 );
				SS_DrawColorRect( this.rx0 + 1, this.ry0 + 1, this.rx1 - 1, this.ry1 - 1, 0.3, 0.5, 0.7, 1 );
				SS_DrawColorRect( this.cx0, this.cy0, this.cx1, this.cy1, 0.4, 0.6, 0.8, 1 );
				
				SS_DrawTextLine_VC( this.caption, this._cachedFont, this.rx0 + 4, this.ry0 + 12, color(1) );
			}
		},
		"window .close-button" = { anchorMode = UI_Anchor_Right, x = -20, y = -22, width = 20, height = 18 },
	}),
	
	// BUTTON
	button_render_bgr = function SS_UI_Theme_Default_button_render_bgr()
	{
		cadd = if( this.clicked, -0.1, if( this.mouseOn, 0.1, 0.0 ) );
		B = 0;
		if( !this.nonclient )
		{
			SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.7+cadd, 0.8+cadd, 0.9+cadd, 1 );
			B = 1;
		}
		SS_DrawColorRect( this.rx0+B, this.ry0+B, this.rx1-B, this.ry1-B, 0.3+cadd, 0.5+cadd, 0.7+cadd, 1 );
	},
	button_render_contents = function SS_UI_Theme_Default_button_render_contents()
	{
		data = this.data;
		icon = @data.icon;
		text = this.caption;
		
		if( this.frame.pushScissorRect( this.rx0 + 2, this.ry0 + 2, this.rx1 - 2, this.ry1 - 2 ) )
		{
			fullwidth = 0;
			if( icon ) fullwidth += icon.width;
			if( text )
			{
				textlen = this._cachedFont.getTextLength( text );
				fullwidth += textlen;
			}
			if( icon && text ) fullwidth += 4;
			
			icon_off = ( this.rx1 - this.rx0 - fullwidth ) / 2;
			text_off = icon_off;
			cy = round( ( this.ry1 + this.ry0 ) * 0.5 );
			if( icon )
			{
				text_off += icon.width + 4;
				SS_Draw({ preset = "box", position = vec2( this.rx0 + round( icon_off + icon.width / 2 ), cy ), scale = vec2( icon.width, icon.height ), texture = icon });
			}
			
			if( text )
			{
				SS_DrawTextLine_VC( text, this._cachedFont, this.rx0 + text_off, cy, color(1,1,1,1) );
			}
			
			this.frame.popScissorRect();
		}
	},
	
	// SCROLL
	scroll_button_size = 0,
	
	// MENU
	menu_renderfunc = function SS_UI_Theme_Default_menu_renderfunc()
	{
		data = this.data;
		
		pad = data.menu_padding;
		
		SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.8, 0.8, 0.8, 1 );
		SS_DrawColorRect( this.rx0+pad, this.ry0+pad, this.rx1-pad, this.ry1-pad, 0.9, 0.9, 0.9, 1 );
		
		SS_DrawColorRect( this.rx0+32, this.ry0+2+pad, this.rx0+33, this.ry1-2-pad, 0.8, 0.8, 0.8, 1 );
		
		x = this.rx0 + pad;
		y = this.ry0 + pad;
		foreach( id, item : data.items )
		{
			disabled = @item.disabled;
			checked = @item.checked;
			
			if( id === data.selected )
				SS_Draw({ preset = "tile", position = [x,y], scale = [data.item_width,data.item_height], color = if(disabled,[0.7,0.7,0.7,0.5],[0.4,0.6,0.8,0.8]) });
			
			if( isset( item, "menu" ) )
				SS_DrawFitted( data.icon_submenu, x + data.item_width - data.item_height, x + data.item_width, y, y + data.item_height );
			
			if( @item.text !== null )
				SS_DrawTextLine_VC( item.text, this._cachedFont, x + 32, y + data.item_height / 2, if(disabled,[0.5,0.5,0.5,1],[0.1,0.1,0.1,1]) );
			else if( disabled )
				SS_Draw({ preset = "tile", position = [x+32,y+data.sep_height/2], scale = [data.item_width-36,1], color = [0.8,0.8,0.8,1] });
			
			if( disabled && @item.text === null )
				y += data.sep_height;
			else
			{
				if( checked !== null )
				{
					// checkbox
					cbx0 = x + 4;
					cby0 = y + 4;
					cbsz = min( 24, data.item_height - 8 );
					cbx1 = cbx0 + cbsz;
					cby1 = cby0 + cbsz;
					SS_DrawColorRect( cbx0, cby0, cbx1, cby1, 0.5, 0.6, 0.7, 1 );
					SS_DrawColorRect( cbx0+1, cby0+1, cbx1-1, cby1-1, 0.9, 0.9, 0.9, 1 );
					if( checked )
						SS_DrawColorRect( cbx0+3, cby0+3, cbx1-3, cby1-3, 0.1, 0.2, 0.4, 1 );
				}
				y += data.item_height;
			}
			y += data.item_spacing;
		}
	},
	menu_item_min_width = 200,
	menu_item_height = 24,
	menu_sep_height = 8,
	menu_item_spacing = 0,
	menu_padding = 4,
	
	// CHECKBOX
	checkbox_border = 1,
	checkbox_padding = 2,
	
	// RADIOBTN
	radiobtn_border = 1,
	radiobtn_padding = 2,
};
