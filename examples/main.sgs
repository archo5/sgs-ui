
include "../bin/sgs-ui";



function draw_fitted( tex, x0, x1, y0, y1 )
{
	dw = x1 - x0;
	dh = y1 - y0;
	if( dw <= 0 || dh <= 0 )
		return;
	
	sw = tex.width;
	sh = tex.height;
	
	da = dw / dh;
	sa = sw / sh;
	
	px = ( x0 + x1 ) * 0.5;
	py = ( y0 + y1 ) * 0.5;
	
	if( da > sa ) // extra width
	{
		w = dh * sa;
		h = dh;
	}
	else // extra height
	{
		w = dw;
		h = dw / sa;
	}
	if( w > sw )
	{
		w = sw;
		h = sh;
	}
	
	px = round( px );
	py = round( py );
	
	draw({ preset = "box", position = [px,py], scale = [w,h], texture = tex });
}


function ui_create_static( parent, x, y, width, height, caption, color, textmode )
{
	Static = ui_create_control( "static" );
	Static.data =
	{
		color = color || [0.5,0.5,0.5,1],
		textmode = textmode || DT_CENTER | DT_VCENTER,
	};
	Static.x = x;
	Static.y = y;
	Static.width = width;
	Static.height = height;
	Static.caption = caption;
	
	function Static.renderfunc()
	{
		data = this.data;
		text = this.caption;
		
		draw({ preset = "tile", position = [this.rx0,this.ry0],
			scale = [this.rx1-this.rx0,this.ry1-this.ry0], color = data.color });
		
		if( text )
		{
			draw_text_rect( text, Font, data.color, data.textmode, this.rx0, this.rx1, this.ry0, this.ry1 );
		}
	}
	
	if( typeof(parent) == "UIControl" )
		parent.addChild( Static );
	else if( typeof(parent) == "UIFrame" )
		parent.root = Static;
	
	return Static;
}

function ui_create_button( parent, x, y, width, height, caption, icon )
{
	Button = ui_create_control( "button" );
	if( typeof(icon) == "string" )
		icon = create_texture( icon );
	Button.data = { icon = icon };
	Button.x = x;
	Button.y = y;
	Button.width = width;
	Button.height = height;
	Button.caption = caption;
	
	orig_callback = Button.callback;
	
	function Button.callback( event ) use( orig_callback )
	{
		if( event.type == EV_NeedFocus )
			return 1;
		if( event.type == EV_ButtonDown && event.button != 0 )
		{
			this.frame.setFocus( this );
			return;
		}
		return orig_callback.thiscall( this, event );
	}
	
	function Button.renderfunc()
	{
		data = this.data;
		icon = _( data, "icon" );
		text = this.caption;
		
		cadd = if( this.clicked, -0.1, if( this.mouseOn, 0.1, 0.0 ) );
		draw_color_rect( this.rx0, this.ry0, this.rx1, this.ry1, 0.7+cadd, 0.8+cadd, 0.9+cadd, 1 );
		draw_color_rect( this.rx0+1, this.ry0+1, this.rx1-1, this.ry1-1, 0.3+cadd, 0.5+cadd, 0.7+cadd, 1 );
		
		fullwidth = 0;
		if( icon ) fullwidth += icon.width;
		if( text ) fullwidth += Font.get_text_length( text );
		if( icon && text ) fullwidth += 4;
		
		icon_off = ( this.rx1 - this.rx0 - fullwidth ) / 2;
		text_off = icon_off;
		cy = round( ( this.ry1 + this.ry0 ) * 0.5 );
		if( icon )
		{
			text_off += icon.width + 4;
			draw({ preset = "box", position = [ this.rx0 + round( icon_off + icon.width / 2 ), cy ], scale = [ icon.width, icon.height ], texture = icon });
		}
		
		if( text )
		{
			draw_text_line_vc( text, Font, this.rx0 + text_off, cy, [1,1,1,1] );
		}
	}
	
	parent.addChild( Button );
	
	return Button;
}



function ui_build_menu( parent, x, y, items, default )
{
	Menu = ui_create_control( "menu" );
	Menu.x = x - parent.x;
	Menu.y = y - parent.y;
	Menu.topmost = true;
	
	items = clone( items );
	// each item can have the following used parameters
	// - text (label text)
	// - info (info text, usually shortcut key info)
	// - func (trigger callback, "checked" is updated before this)
	// - icon (whatever the renderfunc will understand)
	// - checked (null/true/false)
	// - disabled (whether entry is a text or a line separator)
	
	Menu.data =
	{
		item_width = 200,
		item_height = 24,
		sep_height = 8,
		item_spacing = 0,
		menu_padding = 4,
		items = items,
		selected = false,
		
		buttonup_fn = function( e ) use( Menu ){ Menu.callback( e ); },
	};
	
	if( default !== null && default >= 0 && default < items.size )
		Menu.data.selected = default;
	
	ocb = Menu.callback;
	function Menu.callback( event ) use( ocb )
	{
		data = this.data;
		
		if( event.type == EV_Detach )
		{
			this.frame.root.unbindEvent( "buttonup", data.buttonup_fn );
		}
		else if( event.type == EV_HitTest )
		{
			return ocb.thiscall( this, event ) || this.parent.callback( event );
		}
		else if( event.type == EV_Layout )
		{
			ht = 0;
			foreach( i, item : data.items )
			{
				if( i )
					ht += data.item_spacing;
				if( _( item, "disabled" ) && _( item, "text" ) === null )
					ht += data.sep_height;
				else
					ht += data.item_height;
			}
			mp2 = data.menu_padding * 2;
			this.width = data.item_width + mp2;
			this.height = ht + mp2;
		}
		else if( event.type == EV_MouseMove )
		{
			data.selected = false;
			x0 = this.rx0 + data.menu_padding;
			x1 = x0 + data.item_width;
			if( x0 <= event.x && x1 > event.x )
			{
				y0 = this.ry0 + data.menu_padding;
				for( i = 0; i < data.items.size; ++i )
				{
					item = data.items[ i ];
					if( _( item, "disabled" ) && _( item, "text" ) === null )
						ht = data.sep_height;
					else
						ht = data.item_height;
					
					y1 = y0 + ht;
					if( !( _( item, "disabled" ) && _( item, "text" ) === null ) && event.y >= y0 && event.y < y1 )
					{
						data.selected = i;
						break;
					}
					
					y0 = y1 + data.item_spacing;
				}
			}
		}
		else if( event.type == EV_MouseLeave )
		{
			data.selected = false;
			return false;
		}
		else if( event.type == EV_ButtonDown )
		{
			hitevent = ui_create_event();
			hitevent.type = EV_HitTest;
			hitevent.x = event.x;
			hitevent.y = event.y;
			if( this.callback( hitevent ) && !ocb.thiscall( this, hitevent ) )
				this.parent.removeChild( this );
			return true;
		}
		else if( event.type == EV_ButtonUp )
		{
			if( data.selected !== false )
			{
				item = data.items[ data.selected ];
				if( !_( item, "disabled" ) )
				{
					if( isset( item, "checked" ) && item.checked !== null )
						item.checked = !item.checked;
					if( isset( item, "func" ) )
						item.func();
					this.parent.removeChild( this );
				}
			}
			return true;
		}
		
		return ocb.thiscall( this, event );
	}
	
	function Menu.renderfunc()
	{
		data = this.data;
		
		pad = data.menu_padding;
		
		draw({ preset = "tile", position = [this.rx0,this.ry0], scale = [this.width,this.height], color = [0.8,0.8,0.8,1] });
		draw({ preset = "tile", position = [this.rx0+pad,this.ry0+pad], scale = [this.width-pad*2,this.height-pad*2], color = [0.9,0.9,0.9,1] });
		
		draw({ preset = "tile", position = [this.rx0+32,this.ry0+2+pad], scale = [1,this.height-4-pad*2], color = [0.8,0.8,0.8,1] });
		
		x = this.rx0 + pad;
		y = this.ry0 + pad;
		foreach( id, item : data.items )
		{
			disabled = _( item, "disabled" );
			
			if( id === data.selected )
				draw({ preset = "tile", position = [x,y], scale = [data.item_width,data.item_height], color = if(disabled,[0.7,0.7,0.7,0.5],[0.4,0.6,0.8,0.8]) });
			
			if( _( item, "text" ) !== null )
				draw_text_line_vc( item.text, Font, x + 32, y + data.item_height / 2, if(disabled,[0.5,0.5,0.5,1],[0.1,0.1,0.1,1]) );
			else if( disabled )
				draw({ preset = "tile", position = [x+32,y+data.sep_height/2], scale = [data.item_width-36,1], color = [0.8,0.8,0.8,1] });
			
			if( disabled && _( item, "text" ) === null )
				y += data.sep_height;
			else
				y += data.item_height;
			y += data.item_spacing;
		}
	}
	
	parent.addChild( Menu );
	parent.frame.root.bindEvent( "buttonup", Menu.data.buttonup_fn );
	parent.frame.handleMouseMove();
	
	return Menu;
}




function ui_create_textbox( parent, x, y, width, caption, text )
{
	caption ||= "";
	text ||= "";
	
	Textbox = ui_create_control( "textbox" );
	Textbox.x = x;
	Textbox.y = y;
	Textbox.width = width;
	
	Textbox.data =
	{
		padding = 1,
		text_padding = 2,
		height = 24,
		caption = caption,
		
		offset = 0,
		sel_from = text.length,
		sel_to = text.length,
		fsel_from = null,
		fsel_to = null,
		selecting = false,
		chars = string_utf8_decode( text ),
		text = text,
		prevtext = text,
		show_cursor = true,
		cursor_timer = null,
	};
	
	tbdata = Textbox.data;
	
	function tbdata.removeCursorTimer( frame )
	{
		if( this.cursor_timer )
			frame.clearInterval( this.cursor_timer );
		this.cursor_timer = null;
	}
	function tbdata.resetCursorTimer( frame )
	{
		tbdata = this;
		this.removeCursorTimer();
		this.cursor_timer = frame.setInterval( 0.5, function() use( tbdata ) { tbdata.show_cursor = !tbdata.show_cursor; } );
		this.show_cursor = true;
	}
	
	function tbdata.updateSelOffsets()
	{
		this.sel_from = max( 0, min( this.sel_from, this.chars.size ) );
		this.sel_to = max( 0, min( this.sel_to, this.chars.size ) );
		this.fsel_to = 0;
		this.fsel_from = 0;
		
		pc = null;
		for( i = 0; i < this.sel_from; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_from += Font.get_advance( pc, ch );
			pc = ch;
		}
		
		pc = null;
		for( i = 0; i < this.sel_to; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_to += Font.get_advance( pc, ch );
			pc = ch;
		}
	}
	
	function tbdata.updateText()
	{
		this.text = string_utf8_encode( this.chars );
	}
	
	function tbdata.findOffset( ctrl, x, y )
	{
		cpad = this.padding + this.text_padding;
		x -= ctrl.rx0 + cpad - this.offset;
		y -= ctrl.ry0 + cpad;
		
		fmin = 0.0;
		fmax = 0.0;
		pc = null;
		for( i = 0; i < this.chars.size; ++i )
		{
			ch = this.chars[ i ];
			fmax += Font.get_advance( pc, ch );
			if( x <= (fmin+fmax)*0.5 )
				break;
			fmin = fmax;
			pc = ch;
		}
		return i;
	}
	
	tbdata.updateSelOffsets();
	
	ocb = Textbox.callback;
	function Textbox.callback( event ) use( ocb )
	{
		data = this.data;
		
		if( event.type == EV_Detach )
		{
			data.removeCursorTimer( this.frame );
		}
		else if( event.type == EV_Layout )
		{
			this.height = data.height;
		}
		else if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_FocusEnter )
		{
			data.prevtext = data.text;
			data.resetCursorTimer( this.frame );
		}
		else if( event.type == EV_FocusLeave )
		{
			data.removeCursorTimer( this.frame );
			if( data.prevtext != data.text )
				this.callEvent( "commit", event );
		}
		else if( event.type == EV_Char )
		{
			if( event.uchar > 0x1f && event.uchar != 0x7f )
			{
				if( data.sel_from == data.sel_to )
				{
					data.chars.insert( data.sel_from, event.uchar );
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from++;
					data.sel_to++;
				}
				else
				{
					from = data.sel_from;
					to = data.sel_to;
					if( from > to )
					{
						from = data.sel_to;
						to = data.sel_from;
					}
					data.chars.erase( from, to - 1 );
					data.chars.insert( from, event.uchar );
					from++;
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from = from;
					data.sel_to = from;
				}
				data.updateSelOffsets();
			}
		}
		else if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL )
			{
				data.selecting = true;
				data.sel_to = data.sel_from = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets();
			}
		}
		else if( event.type == EV_MouseMove )
		{
			if( event.button == Mouse_ButtonL && data.selecting )
			{
				data.sel_to = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets();
			}
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == Mouse_ButtonL )
				data.selecting = false;
		}
		else if( event.type == EV_KeyDown || event.type == EV_KeyUp )
		{
			key = event.key;
			mods = key & ~KeyMod_Filter;
			key &= KeyMod_Filter;
			down = event.type == EV_KeyDown;
			
			if( down )
			{
				if( key == Key_Left || key == Key_Right )
				{
					if( data.sel_from == data.sel_to || mods & KeyMod_Shift )
						data.sel_to = data.sel_to + if( key == Key_Right, 1, -1 );
					else
						data.sel_to = if( key == Key_Left, min( data.sel_from, data.sel_to ), max( data.sel_from, data.sel_to ) );
					if( !( mods & KeyMod_Shift ) )
						data.sel_from = data.sel_to;
					data.updateSelOffsets();
				}
				else if( key == Key_DelLeft || key == Key_DelRight )
				{
					if( data.sel_from != data.sel_to )
					{
						from = data.sel_from;
						to = data.sel_to;
						if( from > to )
						{
							from = data.sel_to;
							to = data.sel_from;
						}
						data.chars.erase( from, to - 1 );
						data.sel_from = from;
						data.sel_to = from;
					}
					else if( key == Key_DelLeft && data.sel_from > 0 )
					{
						data.chars.erase( data.sel_from - 1 );
						data.sel_from--;
						data.sel_to--;
					}
					else if( key == Key_DelRight && data.sel_from < data.chars.size )
					{
						data.chars.erase( data.sel_from );
					}
					data.updateText();
					this.callEvent( "change", event );
					data.updateSelOffsets();
				}
				else if( key == Key_Cut || key == Key_Copy )
				{
					from = data.sel_from;
					to = data.sel_to;
					if( from > to )
					{
						from = data.sel_to;
						to = data.sel_from;
					}
					// TODO: send data to clipboard (frame)
					if( key == Key_Cut )
					{
						data.chars.erase( from, to - 1 );
						data.sel_from = from;
						data.sel_to = from;
					}
					data.updateText();
					this.callEvent( "change", event );
					data.updateSelOffsets();
				}
				else if( key == Key_Paste )
				{
					// TODO
				}
				else if( key == Key_SelectAll )
				{
					data.sel_from = 0;
					data.sel_to = data.chars.size;
					data.updateSelOffsets();
				}
			}
		}
		
		return ocb.thiscall( this, event );
	}
	
	function Textbox.renderfunc()
	{
		data = this.data;
		
		pad = data.padding;
		tpad = data.text_padding;
		
		draw({ preset = "tile", position = [this.rx0,this.ry0], scale = [this.width,this.height], color = if(this.keyboardFocus,[0.9,0.6,0.3,1],[0.6,0.6,0.6,1]) });
		draw({ preset = "tile", position = [this.rx0+pad,this.ry0+pad], scale = [this.width-pad*2,this.height-pad*2], color = [0.9,0.9,0.9,1] });
		
		x0 = this.rx0 + pad + tpad - data.offset;
		y0 = this.ry0 + pad + tpad;
		yc = ( this.ry0 + this.ry1 ) * 0.5;
		xh = ( this.height-pad*2-tpad*2 - Font.size ) * 0.5;
		
		if( !data.chars && !this.keyboardFocus )
		{
			draw_text_line_vc( data.caption, Font, x0 + xh, yc, [0.1,0.1,0.1,0.5] );
		}
		
		draw_text_line_vc( data.text, Font, x0, yc, [0.1,0.1,0.1,1] );
		
		if( this.keyboardFocus && data.sel_to !== null )
		{
			from = min( data.fsel_from, data.fsel_to );
			to = max( data.fsel_from, data.fsel_to );
			if( from != to )
			{
				draw({ preset = "tile", position = [x0+from,y0], scale = [to-from,this.height-pad*2-tpad*2], color = [0.3,0.6,0.9,0.5] });
			}
			
			if( data.show_cursor )
				draw({ preset = "tile", position = [x0+data.fsel_to,y0], scale = [1,this.height-pad*2-tpad*2], color = [0.1,0.1,0.1,1] });
		}
	}
	
	parent.addChild( Textbox );
	
	return Textbox;
}




function configure()
{
	global sys_exit;

	editor = false;
	
	for( i = 0; i < sys_args.size; ++i )
	{
		var arg = sys_args[ i ];
		if( arg == "-preexit" )
		{
			println( "PREEXIT" );
			sys_exit = true;
		}
		else if( arg == "-profile" )
		{
			enable_profiler();
			println( "PROFILER ENABLED" );
		}
		else if( arg == "-profile-ops" )
		{
			enable_profiler2();
			println( "PROFILER [mode 2] ENABLED" );
		}
		else if( arg == "-editor" )
		{
			editor = true;
		}
	}

	if( editor )
	{
		include "editor/main";
		configure();
	}
}

// global W, H, W1 = 1024, H1 = 576, F1 = "", W2 = 1600, H2 = 900, F2 = "", which = 2;
global W, H, W1 = 1024, H1 = 576, F1 = "vsync", W2 = 1024, H2 = 576, F2 = "vsync", which = 2;

function switch()
{
	global W, H, W1, H1, F1, W2, H2, F2, which;
	
	which = 3 - which;
	if( which == 1 )
	{
		set_video_mode( W1, H1, 32, F1 );
		W = W1; H = H1;
	}
	else
	{
		set_video_mode( W2, H2, 32, F2 );
		W = W2; H = H2;
	}
}

function _( obj, prop ){ return if( isset( obj, prop ), obj.(prop), null ); }

function initialize()
{
	set_caption( "The SGS-SDL Game Framework" );
	set_gl_attrib( SDL_GL_DEPTH_SIZE, 24 );
	set_gl_attrib( SDL_GL_STENCIL_SIZE, 8 );
	switch();
	drawfunc_init();
	
	global Font = create_font( "verdana.ttf", 11 );
	
	
	global FRAME = ui_create_frame();
	global STAT = ui_create_static( FRAME, 0, 0, 1024, 576 );
	global TOPBAR = ui_create_static( STAT, 0, 0, 0, 48, "", [0.8,0.8,0.8,1] );
	TOPBAR.q1x = 1;
	
	ui_create_button( TOPBAR, 0, 0, 48, 24, "File" );
	ui_create_button( TOPBAR, 48, 0, 48, 24, "Edit" );
	
	ui_create_button( TOPBAR, 0, 24, 24, 24, "", "icons/page.png" );
	ui_create_button( TOPBAR, 24, 24, 24, 24, "", "icons/disk.png" );
	ui_create_button( TOPBAR, 48, 24, 24, 24, "", "icons/disk_multiple.png" );
	
	global BTN = ui_create_button( STAT, 100, 100, 100, 30, "Action", "icons/disk.png" );
	BTN.bindEvent( "click", function()
	{
		items =
		[
			{ text = "Test 1", func = function(){ println("Test 1 - function"); } },
			{ text = "Some option", checked = false },
			{ disabled = true },
			{ text = "Disabled", disabled = true },
			{ text = "Exiquit", func = function(){ global sys_exit = true; } },
		];
		ui_build_menu( this.frame.root, this.rx0, this.ry1, items );
	});
	
	ui_create_textbox( STAT, 100, 50, 100, "Key" ).bindEvent( "change", function(){ println( "Updated key: " $ this.data.text ); } );
	ui_create_textbox( STAT, 220, 50, 100, "Value" ).bindEvent( "commit", function(){ println( "Committed value: " $ this.data.text ); } );
}

global lasttime = ftime();
global rotation = 0;

function update()
{
	global lasttime, rotation, P, W, H;
	var curtime = ftime();
	var delta = curtime - lasttime;
	lasttime = curtime;
	if( delta > 1.0/15.0 )
		delta = 1.0/15.0;
	
	rotation += delta * 2;
	
	var cc = [0.1,0.2,0.4];
	clear( cc );
	
	set_camera_ui( 0, W, 0, H );
	
	FRAME.processTimers( delta );
	FRAME.render();
	
	tx = "frame time: " $ ( ftime() - lasttime ) * 1000.0 $ " ms";
	draw_text_line( tx, Font, 101, 1, [0,0,0,1] );
	draw_text_line( tx, Font, 100, 0, [0.9,0.8,0.7,1] );
	
	present();

	sleeptime = 15 - ( ftime() - lasttime ) * 1000;
//	if( sleeptime > 0 ) sleep( sleeptime );
}

function on_event( e )
{
	if( e.type == SDL_QUIT )
		global sys_exit = true;
	if( e.type == SDL_MOUSEMOTION )
	{
		FRAME.doMouseMove( e.x, e.y );
	}
	if( e.type == SDL_MOUSEBUTTONDOWN || e.type == SDL_MOUSEBUTTONUP )
	{
		btn = 0;
		if( e.button == 3 ) btn = 1;
		else if( e.button == 2 ) btn = 2;
		FRAME.doMouseButton( btn, e.type == SDL_MOUSEBUTTONDOWN );
	}
	if( e.type == SDL_KEYUP || e.type == SDL_KEYDOWN )
	{
		key = 0;
		if( e.keycode == SDLK_LEFT ) key = Key_Left;
		else if( e.keycode == SDLK_RIGHT ) key = Key_Right;
		else if( e.keycode == SDLK_UP ) key = Key_Up;
		else if( e.keycode == SDLK_DOWN ) key = Key_Down;
		else if( e.keycode == SDLK_BACKSPACE ) key = Key_DelLeft;
		else if( e.keycode == SDLK_DELETE ) key = Key_DelRight;
		else if( e.keycode == SDLK_TAB ) key = Key_Tab;
		else if( e.keycode == SDLK_X && e.mod & KMOD_CTRL ) key = Key_Cut;
		else if( e.keycode == SDLK_C && e.mod & KMOD_CTRL ) key = Key_Copy;
		else if( e.keycode == SDLK_V && e.mod & KMOD_CTRL ) key = Key_Paste;
		else if( e.keycode == SDLK_Z && e.mod & KMOD_CTRL ) key = Key_Undo;
		else if( e.keycode == SDLK_Y && e.mod & KMOD_CTRL ) key = Key_Redo;
		else if( e.keycode == SDLK_A && e.mod & KMOD_CTRL ) key = Key_SelectAll;
		if( key )
		{
			if( e.mod & KMOD_SHIFT ) key |= KeyMod_Shift;
			// submit event
			FRAME.doKeyPress( key, e.type == SDL_KEYDOWN );
		}
	}
	if( e.type == SDL_KEYDOWN )
	{
		FRAME.doPutChar( e.unicode );
	}
	if( e.type == SDL_KEYDOWN && e.keycode == SDLK_F11 )
		switch();
	if( e.type == SDL_VIDEO_DEVICELOST ) println( "Device lost!" );
	if( e.type == SDL_VIDEO_DEVICERESET ) println( "Device reset!" );
}

function cleanup()
{
}
