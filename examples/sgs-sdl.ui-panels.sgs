

function ui_create_scrollable( parent, x, y, width, height, vscroll, hscroll )
{
	vscroll ||= "auto";
	hscroll ||= "auto";
	
	Scrollable = parent.frame.createControl( "scrollable" );
	Scrollable.x = x;
	Scrollable.y = y;
	Scrollable.width = width;
	Scrollable.height = height;
	Scrollable.data =
	{
		padding = 1,
		scroll_size = 12,
		x0 = 0, x1 = 0, y0 = 0, y1 = 0,
	};
	
	pad = Scrollable.data.padding;
	ssize = Scrollable.data.scroll_size;
	
	scrV = ui_create_vscroll( Scrollable, pad, -pad, ssize, pad * 2 );
	scrH = ui_create_hscroll( Scrollable, -pad, pad, pad * 2, ssize );
	scrV.nonclient = true; scrV.visible = false; scrV.q0x = 1; scrV.q1x = 1; scrV.q1y = 1;
	scrH.nonclient = true; scrH.visible = false; scrH.q0y = 1; scrH.q1y = 1; scrH.q1x = 1;
	
	Scrollable_data = Scrollable.data;
	function Scrollable_data.recalc( Scrollable ) use( scrV, scrH )
	{
		pad = this.padding;
		chlist = Scrollable.children();
		x0 = x1 = y0 = y1 = 0;
		foreach( ch : chlist )
		{
			p0x = ch.rx0 - Scrollable.rx0;
			p0y = ch.ry0 - Scrollable.ry0;
			p1x = ch.rx1 - Scrollable.rx0;
			p1y = ch.ry1 - Scrollable.ry0;
			
			x0 = min( x0, min( p0x, p1x ) );
			x1 = max( x1, max( p0x, p1x ) );
			y0 = min( y0, min( p0y, p1y ) );
			y1 = max( y1, max( p0y, p1y ) );
		}
		
		x1 += pad * 2;
		y1 += pad * 2;
		
		this.x0 = x0; this.x1 = x1;
		this.y0 = y0; this.y1 = y1;
		
		iw = x1 - x0;
		ih = y1 - y0;
		
		showV = ih > Scrollable.height - this.scroll_size;
		showH = iw > Scrollable.width - this.scroll_size;
		
		scrV.visible = showV;
		scrH.visible = showH;
		scrV.data.space = ih;
		scrH.data.space = iw;
		Scrollable.nc_top = pad;
		Scrollable.nc_left = pad;
		Scrollable.nc_right = pad + if( showV, this.scroll_size, 0 );
		Scrollable.nc_bottom = pad + if( showH, this.scroll_size, 0 );
	}
	
	scrV.bindEvent( "change", function() use( Scrollable ){ Scrollable.scroll_y = -this.data.position; } );
	scrH.bindEvent( "change", function() use( Scrollable ){ Scrollable.scroll_x = -this.data.position; } );
	
	orig_callback = Scrollable.callback;
	function Scrollable.callback( event ) use( orig_callback, scrV, scrH )
	{
		data = this.data;
		if( event.type == EV_Layout )
		{
			data.recalc( this );
		}
		else if( event.type == EV_MouseWheel )
		{
			if( scrV.visible )
				scrV.callback( event );
			else if( scrH.visible )
				scrH.callback( event );
			return 0; // stop bubbling
		}
		return orig_callback.thiscall( this, event );
	}
	
	function Scrollable.renderfunc()
	{
		data = this.data;
		SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry1, 0.6, 0.6, 0.6, 1 );
		SS_DrawColorRect( this.rx0 + this.nc_left, this.ry0 + this.nc_top, this.rx1 - this.nc_right, this.ry1 - this.nc_bottom, 0.8, 0.8, 0.8, 1 );
	}
	
	parent.addChild( Scrollable );
	
	return Scrollable;
}

function ui_create_menupanel( parent, items )
{
	MenuPanel = parent.frame.createControl( "menupanel" );
	MenuPanel.q1x = 1;
	MenuPanel.q1y = 1;
	
	items = clone( items );
	foreach( item : items )
	{
		item.text = _( item, "text" );
	}
	// each item can have the following used parameters
	// - text (label text)
	// - func (trigger callback, "checked" is updated before this)
	// - menu (a submenu to display on click/after some time)
	// - disabled (whether entry is a text or a line separator)
	
	MenuPanel.data = mpdata =
	{
		item_height = 24,
		side_padding = 8,
		
		items = items,
		selected = false,
		
		parent_menu = null,
		menu_open = null,
		menu_open_for = null,
	};
	
	function mpdata.recalcItemWidths()
	{
		foreach( item : this.items )
			item.width = Font.getTextLength( item.text ) + this.side_padding * 2;
	}
	
	function mpdata.recalcItemPositions( MenuPanel )
	{
		x = 0;
		y = 0;
		rw = MenuPanel.rx1 - MenuPanel.rx0;
		foreach( item : this.items )
		{
			if( x + item.width > rw )
			{
				x = 0;
				y += this.item_height;
			}
			item.x = x + MenuPanel.rx0;
			item.y = y + MenuPanel.ry0;
			x += item.width;
		}
		MenuPanel.nc_top = y + this.item_height;
	}
	
	function mpdata.removeOpen()
	{
		if( this.menu_open )
		{
			mo = this.menu_open;
			mo.parent.removeChild( mo );
			this.menu_open = null;
		}
		this.menu_open_for = null;
	}
	function mpdata.removeRecursive( cc )
	{
		while( cc && cc.type == "menu" )
		{
			pp = cc.data.parent_menu;
			cc.parent.removeChild( cc );
			cc = pp;
		}
	}
	
	mpdata.recalcItemWidths();
	mpdata.recalcItemPositions( MenuPanel );
	
	ocb = MenuPanel.callback;
	function MenuPanel.callback( event ) use( ocb )
	{
		data = this.data;
		if( event.type == EV_Layout )
		{
			data.recalcItemPositions( this );
			this.frame.handleMouseMove();
		}
		else if( event.type == EV_MouseMove )
		{
			data.selected = false;
			foreach( i, item : data.items )
			{
				if( event.x >= item.x && event.y >= item.y &&
					event.x < item.x + item.width && event.y < item.y + data.item_height )
				{
					data.selected = i;
				}
			}
		}
		else if( event.type == EV_ButtonDown )
		{
			sel = data.selected; // store to avoid modification from the events called
			mof = data.menu_open_for;
			data.removeOpen();
			if( sel !== false )
			{
				item = data.items[ sel ];
				if( !_( item, "disabled" ) )
				{
					if( isset( item, "menu" ) )
					{
						if( sel !== mof )
						{
							data.menu_open = ui_build_menu( this.frame.root, item.x, item.y + data.item_height, item.menu );
							data.menu_open.index = this.index + 1;
							data.menu_open.data.parent_menu = this;
							data.menu_open_for = sel;
							this.frame.handleMouseMove();
						}
					}
					else if( isset( item, "func" ) )
						item.func();
					
					if( !isset( item, "menu" ) )
						data.removeRecursive( data.menu_open );
					else
						data.selected = sel; // restore
				}
			}
		}
		return ocb.thiscall( this, event );
	}
	
	function MenuPanel.renderfunc()
	{
		data = this.data;
		iht = data.item_height;
		
		SS_DrawColorRect( this.rx0, this.ry0, this.rx1, this.ry0 + this.nc_top, 0.9, 0.9, 0.9, 1 );
		
		foreach( i, item : data.items )
		{
			disabled = _( item, "disabled" );
			
			if( data.selected === i )
			{
				if( disabled )
				{
					SS_DrawColorRect( item.x, item.y, item.x + item.width, item.y + iht, 0.5, 0.5, 0.5, 1 );
					SS_DrawColorRect( item.x+1, item.y+1, item.x + item.width-1, item.y + iht-1, 0.8, 0.8, 0.8, 1 );
				}
				else
				{
					SS_DrawColorRect( item.x, item.y, item.x + item.width, item.y + iht, 0.4, 0.5, 0.6, 1 );
					SS_DrawColorRect( item.x+1, item.y+1, item.x + item.width-1, item.y + iht-1, 0.7, 0.8, 0.9, 1 );
				}
			}
			
			col = if( disabled, [0.5,0.5,0.5,1], [0.1,0.1,0.1,1] );
			SS_DrawTextLine_VC( item.text, Font, item.x + data.side_padding, item.y + iht / 2, col );
		}
	}
	
	parent.addChild( MenuPanel );
	
	return MenuPanel;
}

