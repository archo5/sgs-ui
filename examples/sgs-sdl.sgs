
include "../bin/sgs-ui";



function draw_fitted( tex, x0, x1, y0, y1 )
{
	dw = x1 - x0;
	dh = y1 - y0;
	if( dw <= 0 || dh <= 0 )
		return;
	
	sw = tex.width;
	sh = tex.height;
	
	da = dw / dh;
	sa = sw / sh;
	
	px = ( x0 + x1 ) * 0.5;
	py = ( y0 + y1 ) * 0.5;
	
	if( da > sa ) // extra width
	{
		w = dh * sa;
		h = dh;
	}
	else // extra height
	{
		w = dw;
		h = dw / sa;
	}
	if( w > sw )
	{
		w = sw;
		h = sh;
	}
	
	px = round( px );
	py = round( py );
	
	draw({ preset = "box", position = [px,py], scale = [w,h], texture = tex });
}

function draw_color_circle( x, y, radius, numsides, r, g, b, a )
{
	if( numsides < 1 || !numsides )
		numsides = ceil( radius * 8 / M_PI );
	if( numsides < 3 )
		return;
	
	if( ss_using_d3d ){ tmp = r; r = b; b = tmp; }
	g_RB.begin();
	
	ang = 0;
	ad = M_PI * 2 / numsides;
	for( i = 0; i <= numsides; ++i )
	{
		g_RB.f( cos( ang ) * radius + x, sin( ang ) * radius + y ).cf2b( r, g, b, a );
		ang += ad;
	}
	g_RB.draw( null, g_VD_P2CC4, 0, numsides + 1, PT_TRIANGLE_FAN );
}


function ui_create_form( parent )
{
	Form = parent.frame.createControl( "form" );
	Form.data = { ctrls = map() };
	Form.q1x = 1;
	Form.q1y = 1;
	
	Form_data = Form.data;
	function Form_data.getData()
	{
		out = {};
		foreach( ctrl ,: this.ctrls )
		{
			val = ctrl.data.getValue();
			if( val !== null )
			{
				if( isset( out, ctrl.name ) )
					out[ ctrl.name ].push( val );
				else
					out[ ctrl.name ] = [ val ];
			}
			else
			{
				if( !isset( out, ctrl.name ) )
					out[ ctrl.name ] = [];
			}
		}
		return out;
	}
	function Form_data.getList( name )
	{
		out = [];
		foreach( ctrl ,: this.ctrls )
		{
			if( ctrl.name == name )
			{
				val = ctrl.data.getValue();
				if( val !== null )
					out.push( val );
			}
		}
		return out;
	}
	function Form_data.getString( name )
	{
		foreach( ctrl ,: this.ctrls )
		{
			if( ctrl.name == name )
			{
				val = ctrl.data.getValue();
				if( val !== null )
					return val;
			}
		}
		return null;
	}
	
	parent.addChild( Form );
	
	return Form;
}

function form_attach( ctrl )
{
	form = ctrl;
	do
	{
		form = form.parent;
		if( form.type == "form" )
		{
			form.data.ctrls[ ctrl ] = true;
			break;
		}
	}
	while( form.parent );
}

function form_detach( ctrl )
{
	form = ctrl;
	do
	{
		form = form.parent;
		if( form.type == "form" )
		{
			unset( form.data.ctrls, ctrl );
			break;
		}
	}
	while( form.parent );
}

function form_controls_by_name( ctrl, name )
{
	form = ctrl;
	do
	{
		form = form.parent;
		if( form.type == "form" )
		{
			out = [];
			foreach( c ,: form.data.ctrls )
			{
				if( c.name == name )
					out.push( c );
			}
			return out;
		}
	}
	while( form.parent );
	return [];
}


function ui_create_static( parent, x, y, width, height, caption, color, textmode )
{
	Static = parent.frame.createControl( "static" );
	Static.data =
	{
		color = color || [0.5,0.5,0.5,1],
		textcolor = [0.1,0.1,0.1,1],
		textmode = textmode || DT_CENTER | DT_VCENTER,
	};
	Static.x = x;
	Static.y = y;
	Static.width = width;
	Static.height = height;
	Static.caption = caption;
	
	function Static.renderfunc()
	{
		data = this.data;
		text = this.caption;
		
		draw({ preset = "tile", position = [this.rx0,this.ry0],
			scale = [this.rx1-this.rx0,this.ry1-this.ry0], color = data.color });
		
		if( text )
		{
			draw_text_rect( text, Font, data.textcolor, data.textmode, this.rx0, this.rx1, this.ry0, this.ry1 );
		}
	}
	
	if( typeof(parent) == "UIControl" )
		parent.addChild( Static );
	else if( typeof(parent) == "UIFrame" )
		parent.root = Static;
	
	return Static;
}

function ui_create_button( parent, x, y, width, height, caption, icon )
{
	Button = parent.frame.createControl( "button" );
	if( typeof(icon) == "string" )
		icon = create_texture( icon );
	Button.data = { icon = icon };
	Button.x = x;
	Button.y = y;
	Button.width = width;
	Button.height = height;
	Button.caption = caption;
	
	orig_callback = Button.callback;
	
	function Button.callback( event ) use( orig_callback )
	{
		if( event.type == EV_NeedFocus )
			return 1;
		if( event.type == EV_ButtonDown && event.button != 0 )
		{
			this.frame.setFocus( this );
			return;
		}
		return orig_callback.thiscall( this, event );
	}
	
	function Button.renderfunc()
	{
		if( this.rx0 == this.rx1 || this.ry0 == this.ry1 )
			return;
		
		data = this.data;
		icon = _( data, "icon" );
		text = this.caption;
		
		cadd = if( this.clicked, -0.1, if( this.mouseOn, 0.1, 0.0 ) );
		draw_color_rect( this.rx0, this.ry0, this.rx1, this.ry1, 0.7+cadd, 0.8+cadd, 0.9+cadd, 1 );
		draw_color_rect( this.rx0+1, this.ry0+1, this.rx1-1, this.ry1-1, 0.3+cadd, 0.5+cadd, 0.7+cadd, 1 );
		
		if( this.frame.pushScissorRect( this.rx0 + 2, this.ry0 + 2, this.rx1 - 2, this.ry1 - 2 ) )
		{
			fullwidth = 0;
			if( icon ) fullwidth += icon.width;
			if( text )
			{
				textlen = Font.get_text_length( text );
				fullwidth += textlen;
			}
			if( icon && text ) fullwidth += 4;
			
			icon_off = ( this.rx1 - this.rx0 - fullwidth ) / 2;
			text_off = icon_off;
			cy = round( ( this.ry1 + this.ry0 ) * 0.5 );
			if( icon )
			{
				text_off += icon.width + 4;
				draw({ preset = "box", position = [ this.rx0 + round( icon_off + icon.width / 2 ), cy ], scale = [ icon.width, icon.height ], texture = icon });
			}
			
			if( text )
			{
				draw_text_line_vc( text, Font, this.rx0 + text_off, cy, [1,1,1,1] );
			}
			
			this.frame.popScissorRect();
		}
	}
	
	parent.addChild( Button );
	
	return Button;
}

function ui_create_checkbox( parent, x, y, width, height, name, value, checked )
{
	cb_size = 16;
	
	Checkbox = parent.frame.createControl( "checkbox" );
	x = round( x + width / 2 );
	y = round( y + width / 2 );
	Checkbox.x = x - round( cb_size / 2 );
	Checkbox.y = y - round( cb_size / 2 );
	Checkbox.width = cb_size;
	Checkbox.height = cb_size;
	Checkbox.name = name;
	Checkbox.data =
	{
		border = 1,
		padding = 2,
		
		checked = checked || false,
		value = if( value === null, 1, value ),
	};
	
	cbdata = Checkbox.data;
	
	function cbdata.getValue(){ return if( this.checked, this.value, null ); };
	
	orig_callback = Checkbox.callback;
	function Checkbox.callback( event ) use( orig_callback )
	{
		data = this.data;
		
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			form_attach( this );
		}
		else if( event.type == EV_Detach )
		{
			form_detach( this );
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == 0 && this.clicked )
			{
				data.checked = !data.checked;
				this.callEvent( "change", event );
			}
		}
		return orig_callback.thiscall( this, event );
	}
	
	function Checkbox.renderfunc()
	{
		data = this.data;
		
		p1 = data.border;
		p2 = data.padding + p1;
		
		draw_color_rect( this.rx0, this.ry0, this.rx1, this.ry1, 0.5, 0.6, 0.8, 1 );
		
		if( this.clicked )
			draw_color_rect( this.rx0 + p1, this.ry0 + p1, this.rx1 - p1, this.ry1 - p1, 0.8, 0.8, 0.8, 1 );
		else
			draw_color_rect( this.rx0 + p1, this.ry0 + p1, this.rx1 - p1, this.ry1 - p1, 0.9, 0.9, 0.9, 1 );
		
		if( data.checked )
			draw_color_rect( this.rx0 + p2, this.ry0 + p2, this.rx1 - p2, this.ry1 - p2, 0.1, 0.2, 0.4, 1 );
	}
	
	parent.addChild( Checkbox );
	
	return Checkbox;
}

function ui_create_radiobtn( parent, x, y, width, height, name, value, checked )
{
	cb_size = 16;
	
	RadioBtn = parent.frame.createControl( "radiobtn" );
	x = round( x + width / 2 );
	y = round( y + width / 2 );
	RadioBtn.x = x - round( cb_size / 2 );
	RadioBtn.y = y - round( cb_size / 2 );
	RadioBtn.width = cb_size;
	RadioBtn.height = cb_size;
	RadioBtn.name = name;
	RadioBtn.data =
	{
		border = 1,
		padding = 2,
		
		checked = checked || false,
		value = if( value === null, 1, value ),
	};
	
	rbdata = RadioBtn.data;
	
	function rbdata.getValue(){ return if( this.checked, this.value, null ); };
	
	orig_callback = RadioBtn.callback;
	function RadioBtn.callback( event ) use( orig_callback )
	{
		data = this.data;
		
		if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_Attach )
		{
			form_attach( this );
		}
		else if( event.type == EV_Detach )
		{
			form_detach( this );
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == 0 && this.clicked )
			{
				ctrls = form_controls_by_name( this, this.name );
				foreach( ctrl : ctrls )
				{
					if( ctrl.type == "radiobtn" && ctrl != this )
					{
						if( ctrl.data.checked != false )
						{
							ctrl.data.checked = false;
							ctrl.callEvent( "change", event );
						}
					}
				}
				if( data.checked != true )
				{
					data.checked = true;
					this.callEvent( "change", event );
				}
			}
		}
		return orig_callback.thiscall( this, event );
	}
	
	function RadioBtn.renderfunc()
	{
		data = this.data;
		
		p1 = data.border;
		p2 = data.padding + p1;
		
		cx = ( this.rx0 + this.rx1 ) / 2;
		cy = ( this.ry0 + this.ry1 ) / 2;
		radius = round( min( this.rx1 - this.rx0, this.ry1 - this.ry0 ) / 2 );
		
		draw_color_circle( cx, cy, radius, null, 0.5, 0.6, 0.8, 1 );
		
		if( this.clicked )
			draw_color_circle( cx, cy, radius - p1, null, 0.8, 0.8, 0.8, 1 );
		else
			draw_color_circle( cx, cy, radius - p1, null, 0.9, 0.9, 0.9, 1 );
		
		if( data.checked )
			draw_color_circle( cx, cy, radius - p2, null, 0.1, 0.2, 0.4, 1 );
	}
	
	parent.addChild( RadioBtn );
	
	return RadioBtn;
}

function ui_create_scroll( vertical, parent, x, y, width, height, space, window, position )
{
	space ||= 0;
	auto_window = if( window, false, true );
	window ||= if( vertical, height, width );
	position ||= 0;
	
	Scroll = parent.frame.createControl( "scroll" );
	Scroll.x = x;
	Scroll.y = y;
	Scroll.width = width;
	Scroll.height = height;
	Scroll.data =
	{
		button_size = 0,
		move_step = 32,
		min_scroll_length = 16,
		
		vertical = vertical,
		space = space,
		window = window,
		position = position,
		auto_window = auto_window,
	};
	
	bsize = Scroll.data.button_size;
	
	scroll_length = if( vertical, height, width ) - bsize * 2;
	bar_pos = if( space, scroll_length * position / space, 0 );
	bar_length = if( space, scroll_length * window / space, scroll_length );
	
	if( vertical )
	{
		btnUP = ui_create_button( Scroll, 0, 0, 0, bsize, "", "icons/arrow_up.png" );
		btnDN = ui_create_button( Scroll, 0, -bsize, 0, bsize, "", "icons/arrow_down.png" );
		btnCS = ui_create_button( Scroll, 0, bsize + bar_pos, 0, bar_length, "" );
		btnUP.q1x = 1; btnDN.q1x = 1; btnCS.q1x = 1;
		btnDN.q0y = 1; btnDN.q1y = 1;
	}
	else
	{
		btnUP = ui_create_button( Scroll, 0, 0, bsize, 0, "", "icons/arrow_left.png" );
		btnDN = ui_create_button( Scroll, -bsize, 0, bsize, 0, "", "icons/arrow_right.png" );
		btnCS = ui_create_button( Scroll, bsize + bar_pos, 0, bar_length, 0, "" );
		btnUP.q1y = 1; btnDN.q1y = 1; btnCS.q1y = 1;
		btnDN.q0x = 1; btnDN.q1x = 1;
	}
	
	Scroll_data = Scroll.data;
	function Scroll_data.moveRel( dist, Scroll, btnCS )
	{
		opos = this.position;
		this.position += dist;
		maxpos = this.space - this.window;
		if( maxpos < 0 ) maxpos = 0;
		if( this.position < 0 ) this.position = 0;
		if( this.position > maxpos ) this.position = maxpos;
		
		if( this.vertical )
		{
			scroll_length = Scroll.ry1 - Scroll.ry0 - this.button_size * 2;
			btnCS.y = this.button_size + if( this.space, scroll_length * this.position / this.space, 0 );
		}
		else
		{
			scroll_length = Scroll.rx1 - Scroll.rx0 - this.button_size * 2;
			btnCS.x = this.button_size + if( this.space, scroll_length * this.position / this.space, 0 );
		}
		
		Scroll.frame.handleMouseMove();
		
		if( opos != this.position )
		{
			e = ui_create_event();
			if( this.vertical )
				e.y = this.position;
			else
				e.x = this.position;
			Scroll.callEvent( "change", e );
		}
	}
	function Scroll_data.moveToAbs( coord, Scroll, btnCS )
	{
		if( this.vertical )
		{
			rcoord = coord - Scroll.ry0 - this.button_size;
			movelen = Scroll.ry1 - Scroll.ry0 - this.button_size * 2 - btnCS.height;
		}
		else
		{
			rcoord = coord - Scroll.rx0 - this.button_size;
			movelen = Scroll.rx1 - Scroll.rx0 - this.button_size * 2 - btnCS.width;
		}
		np = 0;
		if( movelen )
			np = rcoord / movelen * ( this.space - this.window );
		this.moveRel( np - this.position, Scroll, btnCS );
	}
	function Scroll_data.Scroll_onmousemove( event ) use( Scroll, btnCS )
	{
		if( btnCS.clicked )
		{
			Scroll.data.moveToAbs(
				if( Scroll.data.vertical, event.y - Scroll.frame.getClickOffsetY( event.button ), event.x - Scroll.frame.getClickOffsetX( event.button ) )
				, Scroll, btnCS );
		}
	}
	
	btnUP.bindEvent( "click", function() use( Scroll, btnCS ){ Scroll.data.moveRel( -Scroll.data.move_step, Scroll, btnCS ); } );
	btnDN.bindEvent( "click", function() use( Scroll, btnCS ){ Scroll.data.moveRel( Scroll.data.move_step, Scroll, btnCS ); } );
	
	scroll_orig_callback = Scroll.callback;
	function Scroll.callback( event ) use( scroll_orig_callback, btnCS )
	{
		data = this.data;
		if( event.type == EV_Attach )
		{
			this.frame.root.bindEvent( "globalmousemove", data.Scroll_onmousemove );
		}
		else if( event.type == EV_Detach )
		{
			this.frame.root.unbindEvent( "globalmousemove", data.Scroll_onmousemove );
		}
		else if( event.type == EV_Layout )
		{
			ret = scroll_orig_callback.thiscall( this, event );
			
			scroll_length = if( data.vertical, this.ry1 - this.ry0, this.rx1 - this.rx0 );
			if( data.auto_window )
				data.window = scroll_length;
			
			scroll_length -= data.button_size * 2;
			scroll_length = max( scroll_length, data.min_scroll_length );
			bar_pos = if( data.space, scroll_length * data.position / data.space, 0 );
			bar_length = if( data.space, scroll_length * data.window / data.space, scroll_length );
			
			if( data.vertical )
			{
				btnCS.y = bar_pos + data.button_size;
				btnCS.height = bar_length;
			}
			else
			{
				btnCS.x = bar_pos + data.button_size;
				btnCS.width = bar_length;
			}
			
			return ret;
		}
		else if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL )
				data.moveToAbs( if( data.vertical, event.y - btnCS.height / 2, event.x - btnCS.width / 2 ), this, btnCS );
		}
		else if( event.type == EV_MouseWheel )
		{
			data.moveRel( event.x * data.min_scroll_length, this, btnCS );
			return 0; // stop bubbling
		}
		return scroll_orig_callback.thiscall( this, event );
	}
	
	function Scroll.renderfunc()
	{
		draw_color_rect( this.rx0, this.ry0, this.rx1, this.ry1, 0.8, 0.8, 0.8, 1 );
		draw_color_rect( this.rx0 + 1, this.ry0 + 1, this.rx1 - 1, this.ry1 - 1, 0.7, 0.7, 0.7, 1 );
	}
	
	parent.addChild( Scroll );
	
	return Scroll;
}

function ui_create_hscroll( parent, x, y, width, height, space, window, position ){ return ui_create_scroll( false, parent, x, y, width, height, space, window, position ); }
function ui_create_vscroll( parent, x, y, width, height, space, window, position ){ return ui_create_scroll( true, parent, x, y, width, height, space, window, position ); }


function ui_create_scrollable( parent, x, y, width, height, vscroll, hscroll )
{
	vscroll ||= "auto";
	hscroll ||= "auto";
	
	Scrollable = parent.frame.createControl( "scrollable" );
	Scrollable.x = x;
	Scrollable.y = y;
	Scrollable.width = width;
	Scrollable.height = height;
	Scrollable.data =
	{
		padding = 1,
		scroll_size = 12,
		x0 = 0, x1 = 0, y0 = 0, y1 = 0,
	};
	
	pad = Scrollable.data.padding;
	ssize = Scrollable.data.scroll_size;
	
	scrV = ui_create_vscroll( Scrollable, pad, -pad, ssize, pad * 2 );
	scrH = ui_create_hscroll( Scrollable, -pad, pad, pad * 2, ssize );
	scrV.nonclient = true; scrV.visible = false; scrV.q0x = 1; scrV.q1x = 1; scrV.q1y = 1;
	scrH.nonclient = true; scrH.visible = false; scrH.q0y = 1; scrH.q1y = 1; scrH.q1x = 1;
	
	Scrollable_data = Scrollable.data;
	function Scrollable_data.recalc( Scrollable ) use( scrV, scrH )
	{
		pad = this.padding;
		chlist = Scrollable.children();
		x0 = x1 = y0 = y1 = 0;
		foreach( ch : chlist )
		{
			p0x = ch.rx0 - Scrollable.rx0;
			p0y = ch.ry0 - Scrollable.ry0;
			p1x = ch.rx1 - Scrollable.rx0;
			p1y = ch.ry1 - Scrollable.ry0;
			
			x0 = min( x0, min( p0x, p1x ) );
			x1 = max( x1, max( p0x, p1x ) );
			y0 = min( y0, min( p0y, p1y ) );
			y1 = max( y1, max( p0y, p1y ) );
		}
		
		x1 += pad * 2;
		y1 += pad * 2;
		
		this.x0 = x0; this.x1 = x1;
		this.y0 = y0; this.y1 = y1;
		
		iw = x1 - x0;
		ih = y1 - y0;
		
		showV = ih > Scrollable.height - this.scroll_size;
		showH = iw > Scrollable.width - this.scroll_size;
		
		scrV.visible = showV;
		scrH.visible = showH;
		scrV.data.space = ih;
		scrH.data.space = iw;
		Scrollable.nc_top = pad;
		Scrollable.nc_left = pad;
		Scrollable.nc_right = pad + if( showV, this.scroll_size, 0 );
		Scrollable.nc_bottom = pad + if( showH, this.scroll_size, 0 );
	}
	
	scrV.bindEvent( "change", function() use( Scrollable ){ Scrollable.scroll_y = -this.data.position; } );
	scrH.bindEvent( "change", function() use( Scrollable ){ Scrollable.scroll_x = -this.data.position; } );
	
	orig_callback = Scrollable.callback;
	function Scrollable.callback( event ) use( orig_callback, scrV, scrH )
	{
		data = this.data;
		if( event.type == EV_Layout )
		{
			data.recalc( this );
		}
		else if( event.type == EV_MouseWheel )
		{
			if( scrV.visible )
				scrV.callback( event );
			else if( scrH.visible )
				scrH.callback( event );
			return 0; // stop bubbling
		}
		return orig_callback.thiscall( this, event );
	}
	
	function Scrollable.renderfunc()
	{
		data = this.data;
		draw_color_rect( this.rx0, this.ry0, this.rx1, this.ry1, 0.6, 0.6, 0.6, 1 );
		draw_color_rect( this.rx0 + this.nc_left, this.ry0 + this.nc_top, this.rx1 - this.nc_right, this.ry1 - this.nc_bottom, 0.8, 0.8, 0.8, 1 );
	}
	
	parent.addChild( Scrollable );
	
	return Scrollable;
}


function ui_build_menu( parent, x, y, items, default )
{
	Menu = parent.frame.createControl( "menu" );
	Menu.x = x - parent.x;
	Menu.y = y - parent.y;
	Menu.topmost = true;
	
	items = clone( items );
	// each item can have the following used parameters
	// - text (label text)
	// - info (info text, usually shortcut key info)
	// - func (trigger callback, "checked" is updated before this)
	// - menu (a submenu to display on click/after some time)
	// - icon (whatever the renderfunc will understand)
	// - checked (null/true/false)
	// - disabled (whether entry is a text or a line separator)
	
	Menu.data =
	{
		item_width = 200,
		item_height = 24,
		sep_height = 8,
		item_spacing = 0,
		menu_padding = 4,
		items = items,
		selected = false,
		
		parent_menu = null,
		menu_open = null,
		menu_open_for = null,
		
		buttonup_fn = function( e ) use( Menu ){ Menu.callback( e ); },
	};
	
	if( default !== null && default >= 0 && default < items.size )
		Menu.data.selected = default;
	
	menudata = Menu.data;
	
	function menudata.removeOpen()
	{
		if( this.menu_open )
		{
			mo = this.menu_open;
			mo.parent.removeChild( mo );
			this.menu_open = null;
		}
		this.menu_open_for = null;
	}
	function menudata.removeRecursive( cc )
	{
		while( cc && cc.type == "menu" )
		{
			pp = cc.data.parent_menu;
			cc.parent.removeChild( cc );
			cc = pp;
		}
	}
	
	ocb = Menu.callback;
	function Menu.callback( event ) use( ocb )
	{
		data = this.data;
		
		if( event.type == EV_Detach )
		{
			this.frame.root.unbindEvent( "buttonup", data.buttonup_fn );
			if( data.parent_menu )
			{
				if( data.parent_menu.data.menu_open == this )
					data.parent_menu.data.menu_open = null;
				data.parent_menu = null;
			}
			data.removeOpen();
		}
		else if( event.type == EV_HitTest )
		{
			// definite hit if hit self..
			if( ocb.thiscall( this, event ) )
				return 1;
			// possible hit if hit parent..
			if( this.parent && this.parent.callback( event ) )
			{
				// but only if there's no parent menu or we haven't hit that
				pp = data.parent_menu;
				hit = 1;
				while( pp && pp.type == "menu" )
				{
					if( ocb.thiscall( pp, event ) )
					{
						hit = 0;
						break;
					}
					pp = pp.data.parent_menu;
				}
				return hit;
			}
			return 0;
		}
		else if( event.type == EV_Layout )
		{
			ht = 0;
			foreach( i, item : data.items )
			{
				if( i )
					ht += data.item_spacing;
				if( _( item, "disabled" ) && _( item, "text" ) === null )
					ht += data.sep_height;
				else
					ht += data.item_height;
			}
			mp2 = data.menu_padding * 2;
			this.width = data.item_width + mp2;
			this.height = ht + mp2;
		}
		else if( event.type == EV_MouseMove )
		{
			data.selected = false;
			x0 = this.rx0 + data.menu_padding;
			x1 = x0 + data.item_width;
			if( x0 <= event.x && x1 > event.x )
			{
				y0 = this.ry0 + data.menu_padding;
				for( i = 0; i < data.items.size; ++i )
				{
					item = data.items[ i ];
					if( _( item, "disabled" ) && _( item, "text" ) === null )
						ht = data.sep_height;
					else
						ht = data.item_height;
					
					y1 = y0 + ht;
					if( !( _( item, "disabled" ) && _( item, "text" ) === null ) && event.y >= y0 && event.y < y1 )
					{
						data.selected = i;
						break;
					}
					
					y0 = y1 + data.item_spacing;
				}
			}
			if( data.parent_menu )
			{
				hitevent = ui_create_event();
				hitevent.type = EV_HitTest;
				hitevent.x = event.x;
				hitevent.y = event.y;
				if( ocb.thiscall( this, hitevent ) )
					data.parent_menu.data.selected = data.parent_menu.data.menu_open_for;
			}
		}
		else if( event.type == EV_MouseLeave )
		{
			data.selected = false;
			return false;
		}
		else if( event.type == EV_ButtonDown )
		{
			hitevent = ui_create_event();
			hitevent.type = EV_HitTest;
			hitevent.x = event.x;
			hitevent.y = event.y;
			if( this.callback( hitevent ) && !ocb.thiscall( this, hitevent ) )
				data.removeRecursive( this );
			return true;
		}
		else if( event.type == EV_ButtonUp )
		{
			data.removeOpen();
			if( data.selected !== false )
			{
				item = data.items[ data.selected ];
				if( !_( item, "disabled" ) )
				{
					if( isset( item, "menu" ) )
					{
						if( !data.menu_open )
						{
							my = this.ry0;
							for( i = 0; i < data.selected; ++i )
							{
								it2 = data.items[ i ];
								if( _( it2, "disabled" ) && _( it2, "text" ) === null )
									ht = data.sep_height;
								else
									ht = data.item_height;
								my += ht + data.item_spacing;
							}
							sel = data.selected; // store to avoid modification from the events called in the next line
							data.menu_open = ui_build_menu( this.frame.root, this.rx1 - 4, my, item.menu );
							data.menu_open.index = this.index + 1;
							data.selected = sel;
							data.menu_open.data.parent_menu = this;
							data.menu_open_for = data.selected;
							this.frame.handleMouseMove();
						}
					}
					else if( isset( item, "func" ) )
						item.func();
					
					if( !isset( item, "menu" ) )
						data.removeRecursive( this );
				}
			}
			return true;
		}
		
		return ocb.thiscall( this, event );
	}
	
	function Menu.renderfunc()
	{
		data = this.data;
		
		pad = data.menu_padding;
		
		draw({ preset = "tile", position = [this.rx0,this.ry0], scale = [this.width,this.height], color = [0.8,0.8,0.8,1] });
		draw({ preset = "tile", position = [this.rx0+pad,this.ry0+pad], scale = [this.width-pad*2,this.height-pad*2], color = [0.9,0.9,0.9,1] });
		
		draw({ preset = "tile", position = [this.rx0+32,this.ry0+2+pad], scale = [1,this.height-4-pad*2], color = [0.8,0.8,0.8,1] });
		
		x = this.rx0 + pad;
		y = this.ry0 + pad;
		foreach( id, item : data.items )
		{
			disabled = _( item, "disabled" );
			checked = _( item, "checked" );
			
			if( id === data.selected )
				draw({ preset = "tile", position = [x,y], scale = [data.item_width,data.item_height], color = if(disabled,[0.7,0.7,0.7,0.5],[0.4,0.6,0.8,0.8]) });
			
			if( _( item, "text" ) !== null )
				draw_text_line_vc( item.text, Font, x + 32, y + data.item_height / 2, if(disabled,[0.5,0.5,0.5,1],[0.1,0.1,0.1,1]) );
			else if( disabled )
				draw({ preset = "tile", position = [x+32,y+data.sep_height/2], scale = [data.item_width-36,1], color = [0.8,0.8,0.8,1] });
			
			if( disabled && _( item, "text" ) === null )
				y += data.sep_height;
			else
			{
				if( checked !== null )
				{
					// checkbox
					cbx0 = x + 4;
					cby0 = y + 4;
					cbsz = min( 24, data.item_height - 8 );
					cbx1 = cbx0 + cbsz;
					cby1 = cby0 + cbsz;
					draw_color_rect( cbx0, cby0, cbx1, cby1, 0.5, 0.6, 0.7, 1 );
					draw_color_rect( cbx0+1, cby0+1, cbx1-1, cby1-1, 0.9, 0.9, 0.9, 1 );
					if( checked )
						draw_color_rect( cbx0+3, cby0+3, cbx1-3, cby1-3, 0.1, 0.2, 0.4, 1 );
				}
				y += data.item_height;
			}
			y += data.item_spacing;
		}
	}
	
	parent.addChild( Menu );
	parent.frame.root.bindEvent( "buttonup", Menu.data.buttonup_fn );
	parent.frame.handleMouseMove();
	
	return Menu;
}




function ui_create_textbox( parent, x, y, width, caption, text )
{
	caption ||= "";
	text ||= "";
	
	Textbox = parent.frame.createControl( "textbox" );
	Textbox.x = x;
	Textbox.y = y;
	Textbox.width = width;
	
	Textbox.data =
	{
		padding = 1,
		text_padding = 2,
		height = 24,
		caption = caption,
		
		offset = 0,
		sel_from = text.length,
		sel_to = text.length,
		fsel_from = null,
		fsel_to = null,
		selecting = false,
		chars = string_utf8_decode( text ),
		text = text,
		prevtext = text,
		show_cursor = true,
		cursor_timer = null,
	};
	
	tbdata = Textbox.data;
	
	function tbdata.getValue(){ return this.text; }
	
	function tbdata.removeCursorTimer( frame )
	{
		if( this.cursor_timer )
			frame.clearInterval( this.cursor_timer );
		this.cursor_timer = null;
	}
	function tbdata.resetCursorTimer( frame )
	{
		tbdata = this;
		this.removeCursorTimer();
		this.cursor_timer = frame.setInterval( 0.5, function() use( tbdata ) { tbdata.show_cursor = !tbdata.show_cursor; } );
		this.show_cursor = true;
	}
	
	function tbdata.updateSelOffsets()
	{
		this.sel_from = max( 0, min( this.sel_from, this.chars.size ) );
		this.sel_to = max( 0, min( this.sel_to, this.chars.size ) );
		this.fsel_to = 0;
		this.fsel_from = 0;
		
		pc = null;
		for( i = 0; i < this.sel_from; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_from += Font.get_advance( pc, ch );
			pc = ch;
		}
		
		pc = null;
		for( i = 0; i < this.sel_to; ++i )
		{
			ch = this.chars[ i ];
			this.fsel_to += Font.get_advance( pc, ch );
			pc = ch;
		}
	}
	
	function tbdata.updateText()
	{
		this.text = string_utf8_encode( this.chars );
	}
	
	function tbdata.findOffset( ctrl, x, y )
	{
		cpad = this.padding + this.text_padding;
		x -= ctrl.rx0 + cpad - this.offset;
		y -= ctrl.ry0 + cpad;
		
		fmin = 0.0;
		fmax = 0.0;
		pc = null;
		for( i = 0; i < this.chars.size; ++i )
		{
			ch = this.chars[ i ];
			fmax += Font.get_advance( pc, ch );
			if( x <= (fmin+fmax)*0.5 )
				break;
			fmin = fmax;
			pc = ch;
		}
		return i;
	}
	
	tbdata.updateSelOffsets();
	
	ocb = Textbox.callback;
	function Textbox.callback( event ) use( ocb )
	{
		data = this.data;
		
		if( event.type == EV_Attach )
		{
			form_attach( this );
		}
		if( event.type == EV_Detach )
		{
			form_detach( this );
			data.removeCursorTimer( this.frame );
		}
		else if( event.type == EV_Layout )
		{
			this.height = data.height;
		}
		else if( event.type == EV_NeedFocus )
			return 1;
		else if( event.type == EV_FocusEnter )
		{
			data.prevtext = data.text;
			data.resetCursorTimer( this.frame );
		}
		else if( event.type == EV_FocusLeave )
		{
			data.removeCursorTimer( this.frame );
			if( data.prevtext != data.text )
				this.callEvent( "commit", event );
		}
		else if( event.type == EV_Char )
		{
			if( event.uchar > 0x1f && event.uchar != 0x7f )
			{
				if( data.sel_from == data.sel_to )
				{
					data.chars.insert( data.sel_from, event.uchar );
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from++;
					data.sel_to++;
				}
				else
				{
					from = data.sel_from;
					to = data.sel_to;
					if( from > to )
					{
						from = data.sel_to;
						to = data.sel_from;
					}
					data.chars.erase( from, to - 1 );
					data.chars.insert( from, event.uchar );
					from++;
					data.updateText();
					this.callEvent( "change", event );
					data.sel_from = from;
					data.sel_to = from;
				}
				data.updateSelOffsets();
			}
		}
		else if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL )
			{
				data.selecting = true;
				data.sel_to = data.sel_from = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets();
			}
		}
		else if( event.type == EV_MouseMove )
		{
			if( event.button == Mouse_ButtonL && data.selecting )
			{
				data.sel_to = data.findOffset( this, event.x, event.y );
				data.updateSelOffsets();
			}
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == Mouse_ButtonL )
				data.selecting = false;
		}
		else if( event.type == EV_KeyDown || event.type == EV_KeyUp )
		{
			key = event.key;
			mods = key & ~KeyMod_Filter;
			key &= KeyMod_Filter;
			down = event.type == EV_KeyDown;
			
			if( down )
			{
				if( key == Key_Left || key == Key_Right )
				{
					if( data.sel_from == data.sel_to || mods & KeyMod_Shift )
						data.sel_to = data.sel_to + if( key == Key_Right, 1, -1 );
					else
						data.sel_to = if( key == Key_Left, min( data.sel_from, data.sel_to ), max( data.sel_from, data.sel_to ) );
					if( !( mods & KeyMod_Shift ) )
						data.sel_from = data.sel_to;
					data.updateSelOffsets();
				}
				else if( key == Key_DelLeft || key == Key_DelRight )
				{
					if( data.sel_from != data.sel_to )
					{
						from = data.sel_from;
						to = data.sel_to;
						if( from > to )
						{
							from = data.sel_to;
							to = data.sel_from;
						}
						data.chars.erase( from, to - 1 );
						data.sel_from = from;
						data.sel_to = from;
					}
					else if( key == Key_DelLeft && data.sel_from > 0 )
					{
						data.chars.erase( data.sel_from - 1 );
						data.sel_from--;
						data.sel_to--;
					}
					else if( key == Key_DelRight && data.sel_from < data.chars.size )
					{
						data.chars.erase( data.sel_from );
					}
					data.updateText();
					this.callEvent( "change", event );
					data.updateSelOffsets();
				}
				else if( key == Key_Cut || key == Key_Copy )
				{
					from = data.sel_from;
					to = data.sel_to;
					if( from > to )
					{
						from = data.sel_to;
						to = data.sel_from;
					}
					// TODO: send data to clipboard (frame)
					if( key == Key_Cut )
					{
						data.chars.erase( from, to - 1 );
						data.sel_from = from;
						data.sel_to = from;
					}
					data.updateText();
					this.callEvent( "change", event );
					data.updateSelOffsets();
				}
				else if( key == Key_Paste )
				{
					// TODO
				}
				else if( key == Key_SelectAll )
				{
					data.sel_from = 0;
					data.sel_to = data.chars.size;
					data.updateSelOffsets();
				}
			}
		}
		
		return ocb.thiscall( this, event );
	}
	
	function Textbox.renderfunc()
	{
		data = this.data;
		
		pad = data.padding;
		tpad = data.text_padding;
		cpad = pad + tpad;
		
		draw({ preset = "tile", position = [this.rx0,this.ry0], scale = [this.width,this.height], color = if(this.keyboardFocus,[0.9,0.6,0.3,1],[0.6,0.6,0.6,1]) });
		draw({ preset = "tile", position = [this.rx0+pad,this.ry0+pad], scale = [this.width-pad*2,this.height-pad*2], color = [0.9,0.9,0.9,1] });
		
		x0 = this.rx0 + cpad - data.offset;
		y0 = this.ry0 + cpad;
		yc = ( this.ry0 + this.ry1 ) * 0.5;
		xh = ( this.height-pad*2-tpad*2 - Font.size ) * 0.5;
		
		if( this.frame.pushScissorRect( this.rx0 + cpad, this.ry0 + cpad, this.rx1 - cpad, this.ry1 - cpad ) )
		{
			if( !data.chars && !this.keyboardFocus )
			{
				draw_text_line_vc( data.caption, Font, x0 + xh, yc, [0.1,0.1,0.1,0.5] );
			}
			
			draw_text_line_vc( data.text, Font, x0, yc, [0.1,0.1,0.1,1] );
			
			if( data.sel_to !== null )
			{
				from = min( data.fsel_from, data.fsel_to );
				to = max( data.fsel_from, data.fsel_to );
				if( from != to )
				{
					selcol = if( this.keyboardFocus, [0.3,0.6,0.9,0.5], [0.8,0.8,0.8,0.5] );
					draw({ preset = "tile", position = [x0+from,y0], scale = [to-from,this.height-pad*2-tpad*2], color = selcol });
				}
				
				if( this.keyboardFocus && data.show_cursor )
					draw({ preset = "tile", position = [x0+data.fsel_to,y0], scale = [1,this.height-pad*2-tpad*2], color = [0.1,0.1,0.1,1] });
			}
			
			this.frame.popScissorRect();
		}
	}
	
	parent.addChild( Textbox );
	
	return Textbox;
}




function configure()
{
	global sys_exit;

	editor = false;
	
	for( i = 0; i < sys_args.size; ++i )
	{
		var arg = sys_args[ i ];
		if( arg == "-preexit" )
		{
			println( "PREEXIT" );
			sys_exit = true;
		}
		else if( arg == "-profile" )
		{
			enable_profiler();
			println( "PROFILER ENABLED" );
		}
		else if( arg == "-profile-ops" )
		{
			enable_profiler2();
			println( "PROFILER [mode 2] ENABLED" );
		}
		else if( arg == "-editor" )
		{
			editor = true;
		}
	}

	if( editor )
	{
		include "editor/main";
		configure();
	}
}

// global W, H, W1 = 1024, H1 = 576, F1 = "", W2 = 1600, H2 = 900, F2 = "", which = 2;
global W, H, W1 = 1024, H1 = 576, F1 = "vsync", W2 = 1024, H2 = 576, F2 = "vsync", which = 2;

function switch()
{
	global W, H, W1, H1, F1, W2, H2, F2, which;
	
	which = 3 - which;
	if( which == 1 )
	{
		set_video_mode( W1, H1, 32, F1 );
		W = W1; H = H1;
	}
	else
	{
		set_video_mode( W2, H2, 32, F2 );
		W = W2; H = H2;
	}
}

function _( obj, prop ){ return if( isset( obj, prop ), obj.(prop), null ); }

function initialize()
{
	set_caption( "The SGS-SDL Game Framework" );
	set_gl_attrib( SDL_GL_DEPTH_SIZE, 24 );
	set_gl_attrib( SDL_GL_STENCIL_SIZE, 8 );
	switch();
	drawfunc_init();
	
	global Font = create_font( "verdana.ttf", 11 );
	
	
	global FRAME = ui_create_frame();
	FRAME.width = 1024;
	FRAME.height = 576;
	function FRAME.scissor_func( x0, y0, x1, y1 )
	{
		if( x0 === null )
			set_cliprect( null );
		else
			set_cliprect( x0, x1, y0, y1 );
	}
	
	global FORM = ui_create_form( FRAME.root );
	
	global STAT = ui_create_static( FORM, 10, 10, 1024 - 20, 576 - 20 );
	global TOPBAR = ui_create_static( STAT, 0, 0, 0, 48, "", [0.8,0.8,0.8,1] );
	TOPBAR.q1x = 1;
	
	function formdump()
	{
		printvar( FORM.data.getData() );
	}
	
	ui_create_button( TOPBAR, 0, 0, 48, 24, "File" ).bindEvent( "click", formdump );
	ui_create_button( TOPBAR, 48, 0, 48, 24, "Edit" );
	
	ui_create_button( TOPBAR, 0, 24, 24, 24, "", "icons/page.png" );
	ui_create_button( TOPBAR, 24, 24, 24, 24, "", "icons/disk.png" );
	ui_create_button( TOPBAR, 48, 24, 24, 24, "", "icons/disk_multiple.png" );
	
	global BTN = ui_create_button( STAT, 100, 100, 100, 30, "Action", "icons/disk.png" );
	BTN.bindEvent( "click", function()
	{
		sub3menu =
		[
			{ text = "Third Submenu", disabled = true },
			{ disabled = true },
			{ text = "One option", disabled = true },
			{ text = "..or two!", func = function(){ println("TWOOOOOOOOOOO"); } },
		];
		
		submenu =
		[
			{ text = "One option", disabled = true },
			{ disabled = true },
			{ text = "..or two!" },
			{ text = "3", menu = sub3menu },
		];
		
		items =
		[
			{ text = "Test 1", func = function(){ println("Test 1 - function"); } },
			{ text = "Some option", checked = false },
			{ text = "Some checked option", checked = true },
			{ text = "Submenu?", menu = submenu },
			{ disabled = true },
			{ text = "Disabled", disabled = true },
			{ text = "Exiquit", func = function(){ global sys_exit = true; } },
		];
		ui_build_menu( this.frame.root, this.rx0, this.ry1, items );
	});
	
	tbKey = ui_create_textbox( STAT, 100, 50, 100, "Key" );
	tbKey.bindEvent( "change", function(){ println( "Updated key: " $ this.data.text ); } );
	tbKey.name = "key";
	tbVal = ui_create_textbox( STAT, 220, 50, 100, "Value" );
	tbVal.bindEvent( "commit", function(){ println( "Committed value: " $ this.data.text ); } );
	tbVal.name = "value";
	
	ui_create_checkbox( STAT, 340, 50, 24, 24, "cbox", "set" );
	ui_create_radiobtn( STAT, 364, 50, 24, 24, "rbtn", "A" );
	ui_create_radiobtn( STAT, 388, 50, 24, 24, "rbtn", "B" );
	
	ui_create_vscroll( STAT, 400, 100, 16, 300, 1000, 300, 37 ).bindEvent( "change", function(){ println( "Scrolled to: " $ this.data.position ); } );
	ui_create_hscroll( STAT, 100, 400, 300, 16, 1000, 300, 137 ).bindEvent( "change", function(){ println( "Scrolled to: " $ this.data.position ); } );
	
	SCROLL = ui_create_scrollable( STAT, 500, 100, 200, 300 );
	ui_create_static( SCROLL, 0, 0, 20, 500, string_replace( io_file_read( "../examples/sgs-sdl.sgs" ), ["\r\n","\r","\t"], ["\n","\n","    "] ), [0.9,0.9,0.9,1], DT_LEFT | DT_TOP ).q1x = 1;
}

global lasttime = ftime();
global rotation = 0;

function update()
{
	global lasttime, rotation, P, W, H;
	var curtime = ftime();
	var delta = curtime - lasttime;
	lasttime = curtime;
	if( delta > 1.0/15.0 )
		delta = 1.0/15.0;
	
	rotation += delta * 2;
	
	var cc = [0.1,0.2,0.4];
	clear( cc );
	
	set_camera_ui( 0, W, 0, H );
	
	FRAME.processTimers( delta );
	FRAME.render();
	
//	hctrl = FRAME.getHoverControl();
//	if( hctrl )
//	{
//		draw_color_rect( hctrl.rx0, hctrl.ry0, hctrl.rx1, hctrl.ry1, 0.5, 0.3, 0.1, 0.5 );
//	}
	
//	tx = "frame time: " $ ( ftime() - lasttime ) * 1000.0 $ " ms";
//	draw_text_line( tx, Font, 101, 1, [0,0,0,1] );
//	draw_text_line( tx, Font, 100, 0, [0.9,0.8,0.7,1] );
	
	present();

	sleeptime = 15 - ( ftime() - lasttime ) * 1000;
//	if( sleeptime > 0 ) sleep( sleeptime );
}

function on_event( e )
{
	if( e.type == SDL_QUIT )
		global sys_exit = true;
	if( e.type == SDL_MOUSEMOTION )
	{
		FRAME.doMouseMove( e.x, e.y );
	}
	if( e.type == SDL_MOUSEBUTTONDOWN || e.type == SDL_MOUSEBUTTONUP )
	{
		if( e.button == 4 || e.button == 5 )
			FRAME.doMouseWheel( ( e.button == 5 ) - ( e.button == 4 ) );
		else
		{
			btn = -1;
			if( e.button == 1 ) btn = 0;
			else if( e.button == 3 ) btn = 1;
			else if( e.button == 2 ) btn = 2;
			FRAME.doMouseButton( btn, e.type == SDL_MOUSEBUTTONDOWN );
		}
	}
	if( e.type == SDL_KEYUP || e.type == SDL_KEYDOWN )
	{
		key = 0;
		if( e.keycode == SDLK_LEFT ) key = Key_Left;
		else if( e.keycode == SDLK_RIGHT ) key = Key_Right;
		else if( e.keycode == SDLK_UP ) key = Key_Up;
		else if( e.keycode == SDLK_DOWN ) key = Key_Down;
		else if( e.keycode == SDLK_BACKSPACE ) key = Key_DelLeft;
		else if( e.keycode == SDLK_DELETE ) key = Key_DelRight;
		else if( e.keycode == SDLK_TAB ) key = Key_Tab;
		else if( e.keycode == SDLK_X && e.mod & KMOD_CTRL ) key = Key_Cut;
		else if( e.keycode == SDLK_C && e.mod & KMOD_CTRL ) key = Key_Copy;
		else if( e.keycode == SDLK_V && e.mod & KMOD_CTRL ) key = Key_Paste;
		else if( e.keycode == SDLK_Z && e.mod & KMOD_CTRL ) key = Key_Undo;
		else if( e.keycode == SDLK_Y && e.mod & KMOD_CTRL ) key = Key_Redo;
		else if( e.keycode == SDLK_A && e.mod & KMOD_CTRL ) key = Key_SelectAll;
		else if( e.keycode == SDLK_PAGEUP ) key = Key_PageUp;
		else if( e.keycode == SDLK_PAGEDOWN ) key = Key_PageDown;
		if( key )
		{
			if( e.mod & KMOD_SHIFT ) key |= KeyMod_Shift;
			// submit event
			FRAME.doKeyPress( key, e.type == SDL_KEYDOWN );
		}
	}
	if( e.type == SDL_KEYDOWN )
	{
		FRAME.doPutChar( e.unicode );
	}
	if( e.type == SDL_KEYDOWN && e.keycode == SDLK_F11 )
		switch();
	if( e.type == SDL_VIDEO_DEVICELOST ) println( "Device lost!" );
	if( e.type == SDL_VIDEO_DEVICERESET ) println( "Device reset!" );
}

function cleanup()
{
}
