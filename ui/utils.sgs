

global UndoLayer =
{
	// common error strings
	ERROR_DISABLED = "undo layer disabled (feedback loop prevention)",
	ERROR_NOTMAKINGCHANGE = "not making change",
};

function UndoLayer.create()
{
	data =
	{
		object_types = {},
		feedback_out = {},
		status_cb = {},
		
		undo_states = [],
		current_pos = 0,
		
		change = null,
		
		enabled = true,
	};
	class( data, UndoLayer );
	
	data.registerFeedbackOutput( "undolayer", this._registerChange );
	
	return data;
}

//  S E T U P

function UndoLayer.registerObject( obj, fnobj, fn_add, fn_rem, fn_getstate, fn_getprops, fn_setprops )
{
	if( @this.object_types[ obj ] )
		return WARNING( "object already registered: " $ obj );
	this.object_types[ obj ] =
	{
		fnobj = fnobj,
		fn_add = fn_add,
		fn_rem = fn_rem,
		fn_getstate = fn_getstate,
		fn_getprops = fn_getprops,
		fn_setprops = fn_setprops
	};
}

function UndoLayer.registerFeedbackOutput( name, func ){ this.feedback_out[ name ] = func; }
function UndoLayer.unregisterFeedbackOutput( name ){ unset( this.feedback_out, name ); }
function UndoLayer.registerStatusCallback( name, func ){ this.status_cb[ name ] = func; }
function UndoLayer.unregisterStatusCallback( name ){ unset( this.status_cb, name ); }

function UndoLayer._invokeFeedback( src, action, objtype, id, state, state_to )
{
	foreach( fbo : this.feedback_out )
	{
		this!fbo( src, action, objtype, id, state, state_to );
	}
}

function UndoLayer._invokeStatusCallback( action )
{
	foreach( scb : this.status_cb )
	{
		this!scb( action );
	}
}

//  U N D O - using

function UndoLayer.canUndo(){ return this.current_pos > 0; }
function UndoLayer.canRedo(){ return this.current_pos < this.undo_states.size; }
function UndoLayer.getCurrentPos(){ return this.current_pos; }
function UndoLayer.getStateCount(){ return this.undo_states.size; }
function UndoLayer.getState( i ){ return @this.undo_states[ i ]; }
function UndoLayer.getLastStateName(){ return @this.undo_states.last.name; }

function UndoLayer._undo()
{
	if( this.change !== null )
		return WARNING( "cannot undo - making change" );
	if( this.current_pos == 0 )
		return WARNING( "cannot undo - limit reached" );
	
	cp = --this.current_pos;
	state = this.undo_states[ cp ];
	changes = state.changes;
	
	for( i = changes.size - 1; i >= 0; --i )
	{
		change = changes[ i ];
		if( change.type == "add" )
			this.doRemove( "undolayer", change.objtype, change.id );
		else if( change.type == "remove" )
		{
			id = this.doAdd( "undolayer", change.objtype, change.state );
			if( id != change.id )
				return WARNING( "data link error: returned object ID mismatch" );
		}
		else if( change.type == "change" )
			this.doChange( "undolayer", change.objtype, change.id, change.state_from );
	}
}

function UndoLayer._redo()
{
	if( this.change !== null )
		return WARNING( "cannot undo - making change" );
	if( this.current_pos == this.undo_states.size )
		return WARNING( "cannot redo - limit reached" );
	
	cp = this.current_pos++;
	state = this.undo_states[ cp ];
	changes = state.changes;
	
	for( i = 0; i < changes.size; ++i )
	{
		change = changes[ i ];
		if( change.type == "add" )
		{
			id = this.doAdd( "undolayer", change.objtype, change.state );
			if( id != change.id )
				return WARNING( "data link error: returned object ID mismatch" );
		}
		else if( change.type == "remove" )
			this.doRemove( "undolayer", change.objtype, change.id );
		else if( change.type == "change" )
			this.doChange( "undolayer", change.objtype, change.id, change.state_to );
	}
}

function UndoLayer.undo()
{
	this._undo();
	this._invokeStatusCallback( "move" );
}

function UndoLayer.redo()
{
	this._redo();
	this._invokeStatusCallback( "move" );
}

function UndoLayer.setCurrentPos( pos )
{
	if( pos < 0 || pos > this.undo_states.size )
		return WARNING( "undo position out of bounds" );
	
	while( pos > this.current_pos )
		this._redo();
	while( pos < this.current_pos )
		this._undo();
	
	this._invokeStatusCallback( "move" );
}

//  U N D O - building

function UndoLayer.beginChange()
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	if( this.change !== null )
		return WARNING( "already making change" );
	this.change = [];
}

function UndoLayer.discardChange()
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	if( this.change === null )
		return WARNING( this.ERROR_NOTMAKINGCHANGE );
	this.change = null;
}

function UndoLayer.revertDiscardChange()
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	if( this.change === null )
		return WARNING( this.ERROR_NOTMAKINGCHANGE );
	
	this.commitChange( "__tmp__" );
	this.undo();
	this.pop();
}

function UndoLayer.commitChange( name )
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	if( this.change === null )
		return WARNING( this.ERROR_NOTMAKINGCHANGE );
	
	if( this.undo_states.size != this.current_pos )
	{
		this.undo_states.resize( this.current_pos );
		this._invokeStatusCallback( "resize" );
	}
	this.current_pos++;
	this.undo_states.push({ name = name, changes = this.change });
	this.change = null;
	
	this._invokeStatusCallback( "commit" );
}

function UndoLayer.isMakingChange(){ return this.change !== null; }

function UndoLayer.clearHistory()
{
	this.current_pos = 0;
	this.undo_states.resize( 0 );
	this._invokeStatusCallback( "resize" );
}

//  E D I T I N G

function UndoLayer.doAdd( src, objtype, props )
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	OT = @this.object_types[ objtype ];
	if( !OT )
		return WARNING( "object type not registered: " $ objtype );
	
	fnobj = OT.fnobj;
	fn_add = OT.fn_add;
	fn_getstate = OT.fn_getstate;
	id = fnobj!fn_add( props );
	state = fnobj!fn_getstate( id );
	
	this._invokeFeedback( src, "add", objtype, id, state );
	return id, state;
}

function UndoLayer.doRemove( src, objtype, id )
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	OT = @this.object_types[ objtype ];
	if( !OT )
		return WARNING( "object type not registered: " $ objtype );
	
	fnobj = OT.fnobj;
	fn_rem = OT.fn_rem;
	fn_getstate = OT.fn_getstate;
	state = fnobj!fn_getstate( id );
	fnobj!fn_rem( id );
	
	this._invokeFeedback( src, "remove", objtype, id, state );
	return id, state;
}

function UndoLayer.doChange( src, objtype, id, changes )
{
	if( !this.enabled )
		return WARNING( this.ERROR_DISABLED );
	OT = @this.object_types[ objtype ];
	if( !OT )
		return WARNING( "object type not registered: " $ objtype );
	
	fnobj = OT.fnobj;
	fn_setprops = OT.fn_setprops;
	fn_getprops = OT.fn_getprops;
	state = fnobj!fn_getprops( id, changes );
	fnobj!fn_setprops( id, changes );
	
	this._invokeFeedback( src, "change", objtype, id, state, changes );
	return id, changes, state;
}

//  L O O P B A C K

function UndoLayer._registerChange( src, action, objtype, id, state, state_to )
{
	if( src == "undolayer" )
		return;
	if( this.change === null )
		return WARNING( this.ERROR_NOTMAKINGCHANGE );
	
	if( action == "add" )
	{
		this.change.push({ objtype = objtype, type = "add", id = id, state = state });
	}
	else if( action == "remove" )
	{
		this.change.push({ objtype = objtype, type = "remove", id = id, state = state });
	}
	else if( action == "change" )
	{
		foreach( chg : this.change )
		{
			if( chg.objtype != objtype || chg.type != "change" )
				continue;
			
			chg.state_from = get_merged( state, chg.state_from );
			chg.state_to = get_merged( chg.state_to, state_to );
			return;
		}
		this.change.push({ objtype = objtype, type = "change", id = id, state_from = state, state_to = state_to });
	}
}

