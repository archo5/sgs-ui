
// schema is a map of types
// each type is a dict of properties that describe both data and type itself
// type properties:
// - [string] $type - name of data type valid for this property
// - [string] $name - name to use for labels
// - [string] $hint - a most-generic-first, dot-separated list of descriptors that may aid the choice of a UI control (like "path.image.icon")
// -- other variables may be used by specific types for additional data, such as... --
// - [string] $subtype - name of subtype (one of named root types) valid as one of the items for the value (for arrays and such data types)
// - [string] $options - array of possible value strings (or key-value pairs) to be suggested / allowed
// basic rules:
// - all property names correspond to actual properties inside the data (doing type1.prop2.prop3 in data and schema works and returns related data)

function FNN()
{
	for( i = 0, cnt = va_arg_count(); i < cnt; ++i )
	{
		arg = va_get_arg( i );
		if( arg !== null )
			return arg;
	}
	return null;
}

global UI_DataEdit = {};

function UI_DataEdit._create_label( text )
{
	return UI_CreateStatic( this.data.OpConts.last )[]{ caption = text }.addClass( "label" );
}

function UI_DataEdit._createDefaultLabel( name, schema )
{
	return this._create_label( FNN( @schema."$name", name ) );
}

function UI_DataEdit._create_separator( name, schema, value )
{
	return UI_CreateStatic( this.data.OpConts.last )[]{ caption = FNN( @schema."$name", value, name ) }.addClass( "separator" );
}

function UI_DataEdit._create_checkbox( name, schema, value )
{
	this._createDefaultLabel( name, schema );
	ctrl = UI_CreateCheckbox( this.data.OpConts.last, name, null, !!value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_slider( name, schema, value )
{
	this._createDefaultLabel( name, schema );
	ctrl = UI_CreateSlider( this.data.OpConts.last, name, @schema.min, @schema.max, @schema.stopsize, false, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_textbox( name, schema, value )
{
	this._createDefaultLabel( name, schema );
	ctrl = UI_CreateTextbox( this.data.OpConts.last, name, @schema.textbox_caption, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_switchbutton( name, schema, value )
{
	this._createDefaultLabel( name, schema );
	ctrl = UI_CreateSwitchButton( this.data.OpConts.last, name, @schema.items, @schema.sidebuttons, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_selectbox( name, schema, value )
{
	this._createDefaultLabel( name, schema );
	ctrl = UI_CreateSelectBox( this.data.OpConts.last, name, @schema.items, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_button( name, schema, value )
{
	ctrl = UI_CreateButton( this.data.OpConts.last )[]{ caption = @schema."$name" || name, icon = @schema.icon, class = "value" };
	ctrl.bindEvent( "click", @schema.func || value );
	return ctrl;
}

function UI_DataEdit._create_object( name, schema, value )
{
	return UI_CreateGroupBlock( this.data.OpConts.last, FNN( @schema."$name", name, @schema."$type", "object" ) );
}

function UI_DataEdit._create_array( name, schema, value, path )
{
	ctrl = UI_CreateGroupBlock( this.data.OpConts.last, FNN( @schema."$name", name ) );
	ctrl.addClass( "array" );
	cont = ctrl.getContainer();
	ibox = UI_CreateIntegerBox( cont, "__ibox__" $ name, @value.size || 0 )[]{ class = "array_size" };
	ibox.bindEvent( "change", function()
	{
		cursize = 5; // WHERE IS MY ARRAY
		newsize = this.getValue();
		while( cursize > newsize )
		{
			// REMOVE ITEM
			cursize--;
		}
		while( cursize < newsize )
		{
			// ADD ITEM
			cursize++;
		}
	});
	if( value )
	{
		subschema = schema."$subtype";
		this.data.OpConts.push( cont );
		npath = clone( path );
		foreach( i, v : value )
		{
			npath.push( i );
			this._addCtrls( subschema, npath );
			npath.pop();
		}
		this.data.OpConts.pop();
	}
	return ctrl;
}

function UI_DataEdit.getChangedProperty()
{
	return this.data.changed_prop;
}

function UI_DataEdit.getChangedValue()
{
	return this.data.changed_val;
}

function UI_DataEdit._getDataByPath( path )
{
	o = this.data.dataobj;
	foreach( item : path.part(1) )
		o = o[ item ];
	return o;
}

function UI_DataEdit._pickCtrlType( schema )
{
	if( typeof( schema ) == "string" )
	{
		sch = this.data.schema[ schema ];
		return this._pickCtrlType( sch ), sch;
	}
	type = @schema."$type";
	hint = @schema."$hint";
	
	if( type == "string" )
		return "textbox";
	return type;
}

function UI_DataEdit._push_node_wrapper()
{
	pp = this.data.OpConts.last;
	ctrl = UI_CreateAutoLayout( pp );
	this.data.OpConts.push( ctrl );
}

function UI_DataEdit._pop_node_wrapper()
{
	this.data.OpConts.pop();
}

function UI_DataEdit._addCtrls( schema, path )
{
	value = this._getDataByPath( path );
	
	(type,newschema) = this._pickCtrlType( schema );
	if( newschema )
		schema = newschema;
	
	if( !@this.( "_create_" $ type ) )
		return WARNING( "no such data edit element: " $ type );
	
	this._push_node_wrapper();
	last = this.( "_create_" $ type )( @path.last, schema, value, path );
	this._pop_node_wrapper();
	
	if( null != ( cont = @last.getContainer() ) )
	{
		this.data.OpConts.push( cont );
		foreach( key, subschema : schema )
		{
			if( key[0] == "$" )
				continue;
			npath = clone(path).push( key );
			this._addCtrls( subschema, npath );
		}
		this.data.OpConts.pop();
	}
}
function UI_DataEdit.setData( dataobj, schema )
{
	if( !schema )
		return;
	data = this.data;
	data.schema = schema;
	data.dataobj = dataobj;
	data.AutoLayout.destroyAllChildren(true);
	name = schema."$root";
	this._addCtrls( schema.(name), [name] );
}

function UI_CreateDataEdit( parent, dataobj, schema )
{
	DataEdit = parent.frame.createControl( "dataedit" );
	DataEdit._interface = UI_DataEdit;
	DataEdit.data =
	{
		data = dataobj,
		schema = schema,
		
		changed_prop = null,
		changed_val = null,
	};
	
	Form = UI_CreateForm( DataEdit );
	DataEdit.data.Form = Form;
	Form.bindEvent( "change", function( e ){ /* this.parent._updateData(); */ this.parent.callEvent( "change", e ); } );
	
	Scrollable = UI_CreateScrollable( Form, "auto", false );
	DataEdit.data.Scrollable = Scrollable;
	
	AutoLayout = UI_CreateAutoLayout( Scrollable );
	DataEdit.data.AutoLayout = AutoLayout;
	DataEdit.data.OpConts = [ AutoLayout ];
	
	parent.addChild( DataEdit );
	
	DataEdit.setData( dataobj, schema );
	
	return DataEdit;
}

UI_Controls.dataedit_params = ["data","schema"];
function UI_Controls.dataedit( parent, params )
{
	ctrl = UI_CreateDataEdit( parent, @params.data, @params.schema );
	UI_ConfigControl( ctrl, params );
}

