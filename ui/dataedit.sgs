
// schema is a map of types
// each type is a dict of properties that describe both data and type itself
// type properties:
// - [string] $type - name of data type valid for this property
// - [string] $name - name to use for labels
// - [string] $hint - a most-generic-first, dot-separated list of descriptors that may aid the choice of a UI control (like "path.image.icon")
// -- other variables may be used by specific types for additional data, such as... --
// - [string] $subtype - name of subtype (one of named root types) valid as one of the items for the value (for arrays and such data types)
// - [string] $options - array of possible value strings (or key-value pairs) to be suggested / allowed
// basic rules:
// - all property names correspond to actual properties inside the data (doing type1.prop2.prop3 in data and schema works and returns related data)

global UI_DataEdit = {};

function UI_DataEdit._create_label( text )
{
	return UI_CreateStatic( this.data.OpConts.last )[]{ caption = text }.addClass( "label" );
}

function UI_DataEdit._createDefaultLabel( name, schema )
{
	return this._create_label( @schema."$name" ?? name );
}

function UI_DataEdit._create_separator( name, schema, value, path )
{
	return UI_CreateStatic( this.data.OpConts.last )[]{ caption = @schema."$name" ?? value ?? name }.addClass( "separator" );
}

function UI_DataEdit._create_checkbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateCheckbox( this.data.OpConts.last, name, null, !!value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_checkbox( ctrl, value ){ ctrl.setChecked( value ); }

function UI_DataEdit._create_intbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateIntegerBox( this.data.OpConts.last, name, value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_intbox( ctrl, value ){ ctrl.setValue( value ); }

function UI_DataEdit._create_numbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateNumberBox( this.data.OpConts.last, name, value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_numbox( ctrl, value ){ ctrl.setValue( value ); }

function UI_DataEdit._create_slider( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateSlider( this.data.OpConts.last, name, @schema.min, @schema.max, @schema.stopsize, false, value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_slider( ctrl, value ){ ctrl.setValue( value ); }

function UI_DataEdit._create_textbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateTextbox( this.data.OpConts.last, name, @schema.textbox_caption, value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_textbox( ctrl, value ){ ctrl.setText( value ); }

function UI_DataEdit._create_switchbutton( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateSwitchButton( this.data.OpConts.last, name, @schema.items, @schema.sidebuttons, value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_switchbutton( ctrl, value ){ ctrl.setValue( value ); }

function UI_DataEdit._create_selectbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateSelectBox( this.data.OpConts.last, name, @schema.items, value ).addClass( "value" );
	return ctrl;
}
function UI_DataEdit._update_selectbox( ctrl, value ){ ctrl.setValue( value ); }

function UI_DataEdit._create_button( name, schema, value, path )
{
	ctrl = UI_CreateButton( this.data.OpConts.last )[]{ caption = @schema."$name" ?? path.last, icon = @schema.icon, class = "value" };
	ctrl.bindEvent( "click", @schema.func || value );
	return ctrl;
}
function UI_DataEdit._update_button( ctrl, value ){} // nothing to update

function UI_DataEdit._create_object( name, schema, value, path )
{
	return UI_CreateGroupBlock( this.data.OpConts.last, @schema."$name" ?? path.last ?? @schema."$type" ?? "object" )[]{ name = name };
}
function UI_DataEdit._update_object( ctrl, value ){} // nothing to update

function UI_DataEdit._create_array( name, schema, value, path )
{
	ctrl = UI_CreateGroupBlock( this.data.OpConts.last, @schema."$name" ?? path.last )[]{ name = name };
	ctrl.addClass( "array" );
	cont = ctrl.getContainer();
	
	ctrl.data.elements = elements = [];
	ctrl.data.schema = schema;
	ctrl.data.subschema = schema."$subtype";
	ctrl.data.path = path;
	ctrl.data.dataedit = this;
	ctrl.data.updating = false;
	
	UI_CreateStatic( cont )[]{ caption = "Size" }.addClass( "label" );
	ibox = ctrl.data.ibox = UI_CreateIntegerBox( cont, "__ibox__" $ name, @value.size ?? 0 )[]{ class = "array_size" };
	
	ibox.bindEvent( "change", function array_ibox_change_handler( e )
	{
		rootarr = this.parent;
		while( !rootarr.hasClass( "array" ) )
			rootarr = rootarr.parent;
		elements = rootarr.data.elements;
		dataedit = rootarr.data.dataedit;
		value = dataedit._getDataByPath( rootarr.data.path );
		
		rootarr._updatingLayout = true;
		newsize = this.getValue();
		
		if( elements.size == newsize )
			return;
		first = dataedit._changeBegin( e );
		
		while( elements.size > newsize )
		{
			// REMOVE ITEM
			ctrl = elements.pop();
			// - CONTROLS
		//	dataedit._evictPath( ctrl.name );
			ctrl.parent.destroy(true);
			if( !rootarr.data.updating )
			{
				// - DATA
				value.pop();
				// - EVENT
				dataedit._arrayEvent( false, rootarr.name, value.size, e );
			}
		}
		while( elements.size < newsize )
		{
			// ADD ITEM
			if( !rootarr.data.updating )
			{
				// - EVENT
				dataedit._arrayEvent( true, rootarr.name, value.size, e );
				// - DATA
				newdata = dataedit._recreateFromSchema( rootarr.data.subschema, dataedit.data.item_added );
				value.push( newdata );
			}
			// - CONTROLS
			dataedit.data.OpConts.push( rootarr.getContainer() );
			npath = clone( rootarr.data.path ).push( elements.size );
			ctrl = dataedit._addCtrls( rootarr.data.subschema, npath );
			elements.push( ctrl );
			dataedit.data.OpConts.pop();
			// - cleanup
			dataedit.data.item_added = null;
		}
		rootarr._updatingLayout = false;
		rootarr.onLayoutChange();
		
		if( first )
			dataedit._changeEnd( "array resize", e );
	});
	if( value )
	{
		subschema = schema."$subtype";
		this.data.OpConts.push( cont );
		foreach( i, v : value )
		{
			npath = clone( path ).push( i );
			elements.push( this._addCtrls( subschema, npath ) );
		}
		this.data.OpConts.pop();
	}
	return ctrl;
}
function UI_DataEdit._update_array( ctrl, value, schema, path )
{
	ctrl.data.updating = true;
	ctrl.data.ibox.setValue( value.size );
	foreach( i, v : value )
	{
		npath = clone( path ).push( i );
		this._updateCtrls( schema."$subtype", npath );
	}
	ctrl.data.updating = false;
}

function UI_DataEdit._getDataByPathFrom( obj, path )
{
	foreach( item : path.part(1) )
		obj = obj[ item ];
	return obj;
}

function UI_DataEdit._setDataByPathTo( obj, path, value )
{
	foreach( item : path.part(1,path.size-2) )
		obj = obj[ item ];
	obj[ path.last ] = value;
	return true;
}

function UI_DataEdit._getDataByPath( path ){ return this._getDataByPathFrom( this.data.dataobj, path ); }
function UI_DataEdit._setDataByPath( path, value ){ return this._setDataByPathTo( this.data.dataobj, path, value ); }

function UI_DataEdit._pickCtrlType( schema )
{
	if( typeof( schema ) == "string" )
	{
		sch = this.data.schema[ schema ];
		return this._pickCtrlType( sch ), sch;
	}
	type = @schema."$type";
	if( sch = @this.data.schema[ type ] )
	{
		return this._pickCtrlType( sch ), get_merged( sch, schema );
	}
	hint = @schema."$hint";
	
	if( type == "string" ) return "textbox";
	if( type == "int" ) return "intbox";
	if( type == "float" ) return "numbox";
	return type;
}

function UI_DataEdit._genPathName( path )
{
	out = "";
	foreach( pi : path )
	{
		if( typeof( pi ) == "string" )
			out $= "$s" $ pi;
		else
			out $= "$i" $ tostring( toint( pi ) );
	}
	return out;
}

function UI_DataEdit._placePath( path )
{
	name = this._genPathName( path );
	pmap = this.data.pathmap;
	if( isset( pmap, name ) )
		return name, pmap[ name ];
	pmap[ name ] = path;
	return name, path;
}

function UI_DataEdit._evictPath( pathname )
{
	unset( this.data.pathmap, pathname );
}

function UI_DataEdit._recreateFromSchema( schema, defval )
{
	if( typeof( schema ) == "string" )
		schema = this.data.schema[ schema ];
	
	defval ??= @schema."$default";
	type = schema."$type";
	if( type == "bool" ) return tobool(defval);
	else if( type == "int" ) return toint(defval);
	else if( type == "float" || type == "real" ) return toreal( defval );
	else if( type == "string" ) return if( defval === null, "", tostring( defval ) );
	else if( type == "object" )
	{
		out = {};
		foreach( k, v : schema )
		{
			if( k[0] == "$" )
				continue;
			out[ k ] = this._recreateFromSchema( schema.(k), @defval.(k) );
		}
		return out;
	}
	else if( type == "array" )
	{
		out = [];
		subschema = schema."$subtype";
		if( typeof( defval ) == "array" )
		{
			foreach( v : defval )
			{
				out.push( this._recreateFromSchema( subschema, v ) );
			}
		}
		return out;
	}
	else if( schema = @this.data.schema[ type ] )
	{
		return this._recreateFromSchema( schema, defval );
	}
	return WARNING( "unsupported type in schema: "$type );
}

function UI_DataEdit.recreateDataFromSchema( schema, defval )
{
	this.data = { schema = schema };
	out = this._recreateFromSchema( schema."$root", defval );
	unset( this, "data" );
	return out;
}

function UI_DataEdit._push_node_wrapper( name )
{
	pp = this.data.OpConts.last;
	ctrl = UI_CreateControl( pp, "wrapper" )[]{ name = "__wrap__" $ name, posMode = UI_Pos_SideA };
	this.data.OpConts.push( ctrl );
}

function UI_DataEdit._pop_node_wrapper()
{
	this.data.OpConts.pop();
}

function UI_DataEdit._addCtrls( schema, path )
{
	// retrieve data
	(name,path) = this._placePath( path );
	value = this._getDataByPath( path );
	
	// retrieve type/schema
	(type,newschema) = this._pickCtrlType( schema );
	if( newschema )
		schema = newschema;
	
	// store schema
	this.data.schemap[ name ] = schema;
	
	// validate availability
	if( !@this.( "_create_" $ type ) )
		return WARNING( "no such data edit element (create): " $ type );
	
	// create control
	this._push_node_wrapper( name );
	last = this.( "_create_" $ type )( name, schema, value, path );
	this._pop_node_wrapper();
	
	// create child controls
	if( null != ( cont = @last.getContainer() ) )
	{
		this.data.OpConts.push( cont );
		foreach( key, subschema : schema )
		{
			if( key[0] == "$" )
				continue;
			npath = clone(path).push( key );
			this._addCtrls( subschema, npath );
		}
		this.data.OpConts.pop();
	}
	
	return last;
}

function UI_DataEdit._updateCtrls( schema, path )
{
	// retrieve data
	(name,path) = this._placePath( path );
	value = this._getDataByPath( path );
	
	// retrieve type/schema
	(type,newschema) = this._pickCtrlType( schema );
	if( newschema )
		schema = newschema;
	
	// validate availability
	if( !@this.( "_update_" $ type ) )
		return WARNING( "no such data edit element (update): " $ type );
	
	// find and update relevant control
	ctrl = this._getControlByName( name );
	if( !ctrl )
		return WARNING( "control not found: " $ name );
	this.( "_update_" $ type )( ctrl, value, schema, path );
	
	// update child controls
	foreach( key, subschema : schema )
	{
		if( key[0] == "$" )
			continue;
		npath = clone(path).push( key );
		this._updateCtrls( subschema, npath );
	}
}

function UI_DataEdit._getControlByName( name )
{
	q = this.frame.find( this.data.Form );
	return @q.find( "@=" $ name )[0];
}

function UI_DataEdit.getParentName( name )
{
	if( name == "" )
		return null;
	name = string_explode( name, "$" );
	name.pop();
	return string_implode( name, "$" );
}

function UI_DataEdit.getChangedSchema(){ return this.data.changed_schema; }
function UI_DataEdit.getChangedProperty(){ return this.data.changed_prop; }
function UI_DataEdit.getChangedIndex(){ return this.data.changed_index; }
function UI_DataEdit.getChangeType(){ return this.data.change_type; }
function UI_DataEdit.getLastChange(){ return this.data.changed_prop, this.data.change_type, this.data.changed_index, this.data.changed_schema; }
function UI_DataEdit.getPathByName( name ){ return @this.data.pathmap[ name ]; }
function UI_DataEdit.getSchemaByName( name ){ return @this.data.schemap[ name ]; }

function UI_DataEdit.getValueByName( name )
{
	pmap = this.data.pathmap;
	if( isset( pmap, name ) )
		return this._getDataByPath( pmap[ name ] ), true;
	return null, false;
}

function UI_DataEdit._setValueByName( name, value )
{
	pmap = this.data.pathmap;
	if( isset( pmap, name ) )
		return this._setDataByPath( pmap[ name ], value );
	return false;
}

function UI_DataEdit.applyChangeToObject( obj )
{
	data = this.data;
	cs = data.changed_schema;
	cp = data.changed_prop;
	ci = data.changed_index;
	ct = data.change_type;
	pmap = this.data.pathmap;
	if( isset( pmap, cp ) )
	{
		path = pmap[ cp ];
		if( ct == "add" )
		{
			arr = this._getDataByPathFrom( obj, path );
			arr.insert( ci, this._recreateFromSchema( cs ) );
		}
		else if( ct == "remove" )
		{
			arr.erase( ci );
		}
		else
		{
			this._setDataByPathTo( obj, path, this._getDataByPath( path ) );
		}
	}
}

function UI_DataEdit.setItemAdded( obj )
{
	this.data.item_added = obj;
}

function UI_DataEdit.getSchema(){ return this.data.schema; }
function UI_DataEdit.getData(){ return this.data.dataobj; }
function UI_DataEdit.getChangeName(){ return this.data.change_name; }

function UI_DataEdit.setData( dataobj, schema )
{
	if( !schema )
		return;
	data = this.data;
	data.AutoLayout.destroyAllChildren( true, 1 );
	data.schema = schema;
	data.pathmap = {};
	data.schemap = {};
	root = schema."$root";
	name = if( typeof(root) == "string", root, root."$type" );
	data.dataobj = this._recreateFromSchema( root, dataobj );
	this._addCtrls( root, [name] );
}

function UI_DataEdit.updateData( dataobj )
{
	data = this.data;
	if( !data.schema )
		return WARNING( "no data set previously" );
	schema = data.schema;
	root = schema."$root";
	name = if( typeof(root) == "string", root, root."$type" );
	data.dataobj = this._recreateFromSchema( root, dataobj );
	this._updateCtrls( root, [name] );
}

function UI_DataEdit.unsetData()
{
	data = this.data;
	data.AutoLayout.destroyAllChildren( true, 1 );
	data.schema = null;
	data.pathmap = {};
	data.schemap = {};
	data.dataobj = null;
}

function UI_DataEdit._arrayEvent( addrem, name, idx, event )
{
	if( !event )
		event = UI_CreateEvent();
	data = this.data;
	data.changed_schema = @data.schemap[ name ];
	data.changed_prop = name;
	data.changed_index = idx;
	data.change_type = if( addrem, "add", "remove" );
	data.item_added = null;
	this.callEvent( "edit", event );
	this.callEvent( "change", event );
}

function UI_DataEdit._changeBegin( event )
{
	data = this.data;
	if( data.change_count == 0 )
	{
		data.change_name = null;
		this.callEvent( "history", event ?? UI_CreateEvent() );
	}
	return 0 == data.change_count++;
}

function UI_DataEdit._changeEnd( name, event )
{
	data = this.data;
	data.change_count--;
	if( data.change_count == 0 )
	{
		data.change_name = name;
		this.callEvent( "history", event ?? UI_CreateEvent() );
	}
}

function UI_CreateDataEdit( parent, dataobj, schema )
{
	DataEdit = parent.frame.createControl( "dataedit" );
	DataEdit._interface = UI_DataEdit;
	DataEdit.data =
	{
		data = dataobj,
		schema = schema,
		
		pathmap = {},
		schemap = {},
		
		changed_schema = null,
		changed_prop = null,
		changed_index = null,
		change_type = null,
		item_added = null,
		
		change_count = 0,
		change_name = null,
	};
	
	Form = UI_CreateForm( DataEdit );
	DataEdit.data.Form = Form;
	Form.bindEvent( "edit", function( e )
	{
		dataedit = this.parent;
		chgname = this.getLastChange();
		if( chgname[0] == "_" )
			return;
		data = dataedit.data;
		data.changed_schema = @data.schemap[ chgname ];
		data.changed_prop = chgname;
		data.changed_index = null;
		data.change_type = "edit";
		data.item_added = null;
		dataedit._setValueByName( chgname, this.getString( chgname ) );
		dataedit.callEvent( "edit", e );
	});
	Form.bindEvent( "change", function( e )
	{
		dataedit = this.parent;
		(chgname,chgtype) = this.getLastChange();
		if( chgtype == "add" || chgtype == "remove" )
			return;
		if( chgname[0] == "_" )
			return;
		first = dataedit._changeBegin( e );
		data = dataedit.data;
		data.changed_schema = @data.schemap[ chgname ];
		data.changed_prop = chgname;
		data.changed_index = null;
		data.change_type = "edit";
		data.item_added = null;
		dataedit._setValueByName( chgname, this.getString( chgname ) );
		dataedit.callEvent( "change", e );
		if( first )
			dataedit._changeEnd( "form edit", e );
	});
	
	DataEdit.data.AutoLayout = AutoLayout = UI_CreateControl( Form, "datacontainer" )[]{ posMode = UI_Pos_SideA };
	UI_MakeScrollable( AutoLayout, "auto", false );
	
	DataEdit.data.OpConts = [ AutoLayout ];
	
	parent.addChild( DataEdit );
	
	DataEdit.setData( dataobj, schema );
	
	return DataEdit;
}

UI_Controls.dataedit_params = ["data","schema"];
function UI_Controls.dataedit( parent, params )
{
	ctrl = UI_CreateDataEdit( parent, @params.data, @params.schema );
	UI_ConfigControl( ctrl, params );
}

