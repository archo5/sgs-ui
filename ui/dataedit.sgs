
// schema is a map of types
// each type is a dict of properties that describe both data and type itself
// type properties:
// - [string] $type - name of data type valid for this property
// - [string] $name - name to use for labels
// - [string] $hint - a most-generic-first, dot-separated list of descriptors that may aid the choice of a UI control (like "path.image.icon")
// -- other variables may be used by specific types for additional data, such as... --
// - [string] $subtype - name of subtype (one of named root types) valid as one of the items for the value (for arrays and such data types)
// - [string] $options - array of possible value strings (or key-value pairs) to be suggested / allowed
// basic rules:
// - all property names correspond to actual properties inside the data (doing type1.prop2.prop3 in data and schema works and returns related data)

function FNN()
{
	for( i = 0, cnt = va_arg_count(); i < cnt; ++i )
	{
		arg = va_get_arg( i );
		if( arg !== null )
			return arg;
	}
	return null;
}

global UI_DataEdit = {};

function UI_DataEdit._create_label( text )
{
	return UI_CreateStatic( this.data.OpConts.last )[]{ caption = text }.addClass( "label" );
}

function UI_DataEdit._createDefaultLabel( name, schema )
{
	return this._create_label( FNN( @schema."$name", name ) );
}

function UI_DataEdit._create_separator( name, schema, value, path )
{
	return UI_CreateStatic( this.data.OpConts.last )[]{ caption = FNN( @schema."$name", value, name ) }.addClass( "separator" );
}

function UI_DataEdit._create_checkbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateCheckbox( this.data.OpConts.last, name, null, !!value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_intbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateIntegerBox( this.data.OpConts.last, name, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_slider( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateSlider( this.data.OpConts.last, name, @schema.min, @schema.max, @schema.stopsize, false, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_textbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateTextbox( this.data.OpConts.last, name, @schema.textbox_caption, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_switchbutton( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateSwitchButton( this.data.OpConts.last, name, @schema.items, @schema.sidebuttons, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_selectbox( name, schema, value, path )
{
	this._createDefaultLabel( path.last, schema );
	ctrl = UI_CreateSelectBox( this.data.OpConts.last, name, @schema.items, value ).addClass( "value" );
	return ctrl;
}

function UI_DataEdit._create_button( name, schema, value, path )
{
	ctrl = UI_CreateButton( this.data.OpConts.last )[]{ caption = FNN( @schema."$name" || path.last ), icon = @schema.icon, class = "value" };
	ctrl.bindEvent( "click", @schema.func || value );
	return ctrl;
}

function UI_DataEdit._create_object( name, schema, value, path )
{
	return UI_CreateGroupBlock( this.data.OpConts.last, FNN( @schema."$name", path.last, @schema."$type", "object" ) )[]{ name = name };
}

function UI_DataEdit._create_array( name, schema, value, path )
{
	ctrl = UI_CreateGroupBlock( this.data.OpConts.last, FNN( @schema."$name", path.last ) )[]{ name = name };
	ctrl.addClass( "array" );
	cont = ctrl.getContainer();
	
	ctrl.data.elements = elements = [];
	ctrl.data.schema = schema;
	ctrl.data.subschema = schema."$subtype";
	ctrl.data.path = path;
	ctrl.data.value = value;
	ctrl.data.dataedit = this;
	
	UI_CreateStatic( cont )[]{ caption = "Size" }.addClass( "label" );
	ibox = UI_CreateIntegerBox( cont, "__ibox__" $ name, @value.size || 0 )[]{ class = "array_size" };
	
	ibox.bindEvent( "change", function array_ibox_change_handler()
	{
		rootarr = this.parent;
		while( !rootarr.hasClass( "array" ) )
			rootarr = rootarr.parent;
		elements = rootarr.data.elements;
		dataedit = rootarr.data.dataedit;
		
		newsize = this.getValue();
		while( elements.size > newsize )
		{
			// REMOVE ITEM
			ctrl = elements.pop();
			// - CONTROLS
		//	dataedit._evictPath( ctrl.name );
			ctrl.parent.destroy(true);
			// - DATA
			rootarr.data.value.pop();
			// - EVENT
		}
		while( elements.size < newsize )
		{
			// ADD ITEM
			// - DATA
			newdata = dataedit._recreateFromSchema( rootarr.data.subschema );
			rootarr.data.value.push( newdata );
			// - CONTROLS
			dataedit.data.OpConts.push( rootarr.getContainer() );
			npath = clone( rootarr.data.path ).push( elements.size );
			ctrl = dataedit._addCtrls( rootarr.data.subschema, npath );
			elements.push( ctrl );
			dataedit.data.OpConts.pop();
			// - EVENT
		}
	});
	if( value )
	{
		subschema = schema."$subtype";
		this.data.OpConts.push( cont );
		foreach( i, v : value )
		{
			npath = clone( path ).push( i );
			elements.push( this._addCtrls( subschema, npath ) );
		}
		this.data.OpConts.pop();
	}
	return ctrl;
}

function UI_DataEdit._deepCloneDataItem( item )
{
	copy = clone( item );
	if( @get_iterator( copy ) )
	{
		foreach( k, v : copy )
		{
			copy[ k ] = this._deepCloneDataItem( v );
		}
	}
	return copy;
}

function UI_DataEdit._getDataByPath( path )
{
	o = this.data.dataobj;
	foreach( item : path.part(1) )
		o = o[ item ];
	return o;
}

function UI_DataEdit._setDataByPath( path, value )
{
	o = this.data.dataobj;
	foreach( item : path.part(1,path.size-2) )
		o = o[ item ];
	o[ path.last ] = value;
	return true;
}

function UI_DataEdit._pickCtrlType( schema )
{
	if( typeof( schema ) == "string" )
	{
		sch = this.data.schema[ schema ];
		return this._pickCtrlType( sch ), sch;
	}
	type = @schema."$type";
	hint = @schema."$hint";
	
	if( type == "string" )
		return "textbox";
	return type;
}

function UI_DataEdit._genPathName( path )
{
	out = "";
	foreach( pi : path )
	{
		if( typeof( pi ) == "string" )
			out $= "$s" $ pi;
		else
			out $= "$i" $ tostring( toint( pi ) );
	}
	return out;
}

function UI_DataEdit._placePath( path )
{
	name = this._genPathName( path );
	pmap = this.data.pathmap;
	if( isset( pmap, name ) )
		return name, pmap[ name ];
	pmap[ name ] = path;
	return name, path;
}

function UI_DataEdit._evictPath( pathname )
{
	unset( this.data.pathmap, pathname );
}

function UI_DataEdit._recreateFromSchema( schema, defval )
{
	if( typeof( schema ) == "string" )
		schema = this.data.schema[ schema ];
	
	type = schema."$type";
	if( type == "bool" ) return tobool(defval);
	else if( type == "int" ) return toint(defval);
	else if( type == "float" || type == "real" ) return toreal( defval );
	else if( type == "string" ) return if( defval === null, "", tostring( defval ) );
	else if( type == "object" )
	{
		out = {};
		foreach( k, v : schema )
		{
			if( k[0] == "$" )
				continue;
			out[ k ] = this._recreateFromSchema( schema.(k), @defval.(k) );
		}
		return out;
	}
	else if( type == "array" ) return [];
	return WARNING( "unsupported type in schema" );
}

function UI_DataEdit._push_node_wrapper( name )
{
	pp = this.data.OpConts.last;
	ctrl = pp.frame.createControl( "container" )[]{ name = "__wrap__" $ name, posMode = UI_Pos_SideA };
	pp.addChild( ctrl );
	this.data.OpConts.push( ctrl );
}

function UI_DataEdit._pop_node_wrapper()
{
	this.data.OpConts.pop();
}

function UI_DataEdit._addCtrls( schema, path )
{
	(name,path) = this._placePath( path );
	value = this._getDataByPath( path );
	
	(type,newschema) = this._pickCtrlType( schema );
	if( newschema )
		schema = newschema;
	
	if( !@this.( "_create_" $ type ) )
		return WARNING( "no such data edit element: " $ type );
	
	this._push_node_wrapper( name );
	last = this.( "_create_" $ type )( name, schema, value, path );
	this._pop_node_wrapper();
	
	if( null != ( cont = @last.getContainer() ) )
	{
		this.data.OpConts.push( cont );
		foreach( key, subschema : schema )
		{
			if( key[0] == "$" )
				continue;
			npath = clone(path).push( key );
			this._addCtrls( subschema, npath );
		}
		this.data.OpConts.pop();
	}
	
	return last;
}

function UI_DataEdit._setValueByName( name, value )
{
	pmap = this.data.pathmap;
	if( isset( pmap, name ) )
		return this._setDataByPath( pmap[ name ], value );
	return false;
}

function UI_DataEdit.getChangedProperty(){ return this.data.changed_prop; }
function UI_DataEdit.getChangeType(){ return this.data.change_type; }
function UI_DataEdit.getLastChange(){ return this.data.changed_prop, this.data.change_type; }

function UI_DataEdit.getValueByName( name )
{
	pmap = this.data.pathmap;
	if( isset( pmap, name ) )
		return this._getDataByPath( pmap[ name ] ), true;
	return null, false;
}

function UI_DataEdit.getData()
{
	return this.data.dataobj;
}

function UI_DataEdit.setData( dataobj, schema )
{
	if( !schema )
		return;
	data = this.data;
	data.schema = schema;
	data.dataobj = this._deepCloneDataItem( dataobj );
	data.AutoLayout.destroyAllChildren( true, 1 );
	name = schema."$root";
	this._addCtrls( schema.(name), [name] );
}

function UI_CreateDataEdit( parent, dataobj, schema )
{
	DataEdit = parent.frame.createControl( "dataedit" );
	DataEdit._interface = UI_DataEdit;
	DataEdit.data =
	{
		data = dataobj,
		schema = schema,
		
		pathmap = {},
		
		changed_prop = null,
		change_type = null,
	};
	
	Form = UI_CreateForm( DataEdit );
	DataEdit.data.Form = Form;
	Form.bindEvent( "edit", function( e )
	{
		dataedit = this.parent;
		chgname = this.getLastChange();
		if( chgname[0] == "_" )
			return;
		dataedit.data.changed_prop = chgname;
		dataedit.data.change_type = "edit";
		dataedit._setValueByName( chgname, this.getString( chgname ) );
		dataedit.callEvent( "edit", e );
	});
	Form.bindEvent( "change", function( e )
	{
		dataedit = this.parent;
		(chgname,chgtype) = this.getLastChange();
		if( chgtype == "add" || chgtype == "remove" )
			return;
		if( chgname[0] == "_" )
			return;
		dataedit.data.changed_prop = chgname;
		dataedit.data.change_type = "edit";
		dataedit._setValueByName( chgname, this.getString( chgname ) );
		dataedit.callEvent( "change", e );
	});
	
	DataEdit.data.AutoLayout = AutoLayout = parent.frame.createControl( "container" )[]{ posMode = UI_Pos_SideA };
	Form.addChild( AutoLayout );
	UI_MakeScrollable( AutoLayout, "auto", false );
	
	DataEdit.data.OpConts = [ AutoLayout ];
	
	parent.addChild( DataEdit );
	
	DataEdit.setData( dataobj, schema );
	
	return DataEdit;
}

UI_Controls.dataedit_params = ["data","schema"];
function UI_Controls.dataedit( parent, params )
{
	ctrl = UI_CreateDataEdit( parent, @params.data, @params.schema );
	UI_ConfigControl( ctrl, params );
}

