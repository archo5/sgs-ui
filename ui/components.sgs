
//
// HOVER ANIMATOR
//

function UI_HoverAnimator_Proc( event, com )
{
	if( event.type == EV_AddComponent )
	{
		foreach( k, v : com.data.state0 )
			this.(k) = v;
	}
	else if( event.type == EV_MouseEnter )
	{
		this.stop(true).animate( com.data.state1, com.data.time );
	}
	else if( event.type == EV_MouseLeave )
	{
		this.stop(true).animate( com.data.state0, com.data.time );
	}
}

function UI_CreateHoverAnimator( ctrl, state0, state1, time )
{
	ctrl.addComponent( "hoveranimator", UI_HoverAnimator_Proc, { state0 = state0, state1 = state1, time = time } );
}


//
// SCROLLABLE
//

function UI_Scrollable_doScrolling( factor, ctrl )
{
	factor ??= 1;
	data = this.data;
	if( data.cursor_scroll )
	{
		curx = data.cursor_x;
		cury = data.cursor_y;
		if( data.scrV.visible && curx >= ctrl.cx0 && curx < ctrl.cx1 )
		{
			scrfac = 0;
			if( cury >= ctrl.cy0 && cury < ctrl.py0 ) scrfac--;
			if( cury >= ctrl.py1 && cury < ctrl.cy1 ) scrfac++;
			if( scrfac )
				data.scrV.moveRel( data.scrV.data.mousemove_step * scrfac * factor );
		}
		if( data.scrH.visible && cury >= ctrl.cy0 && cury < ctrl.cy1 )
		{
			scrfac = 0;
			if( curx >= ctrl.cx0 && curx < ctrl.px0 ) scrfac--;
			if( curx >= ctrl.px1 && curx < ctrl.cx1 ) scrfac++;
			if( scrfac )
				data.scrH.moveRel( data.scrH.data.mousemove_step * scrfac * factor );
		}
		
		me = this;
		ctrl.frame.setTimeout( 1/60, function() use( me, ctrl ){ me!UI_Scrollable_doScrolling( 1/60, ctrl ); } );
	}
}

function UI_Scrollable_Proc( event, com )
{
	data = com.data;
	if( event.type == EV_AddComponent )
	{
		this.addClass( "is-scrollable" );
	}
	else if( event.type == EV_RemComponent )
	{
		this.removelass( "is-scrollable" );
		data.scrH.destroy(true);
		data.scrV.destroy(true);
	}
	else if( event.type == EV_Changed && event.subtype & EV_Changed_Box )
	{
		scrV = data.scrV;
		scrH = data.scrH;
		(x0,y0,x1,y1) = this.getChildAABB( false );
		
		iw = x1 - x0;
		ih = y1 - y0;
	//	println({iw=iw,ih=ih,x0=x0,y0=y0,x1=x1,y1=y1});
		
		showV = if( data.vscroll === "auto", ih > this.clientHeight, data.vscroll );
		showH = if( data.hscroll === "auto", iw > this.clientWidth, data.hscroll );
		
		scrV.visible = showV;
		scrH.visible = showH;
		scrV.data.space = ih;
		scrH.data.space = iw;
		fs = this.filteredStyle;
		this.nonClientRight = fs.nonClientRight + if( showV, scrV.realWidth, 0 );
		this.nonClientBottom = fs.nonClientBottom + if( showH, scrH.realHeight, 0 );
		this._updateFullRect();
		this._updateChildRects();
	}
	else if( event.type == EV_MouseWheel )
	{
		if( data.scrV.visible )
			data.scrV.callback( event );
		if( data.scrH.visible )
		{
			event.y = event.x;
			data.scrH.callback( event );
		}
		return 1; // stop bubbling
	}
	else if( event.type == EV_MouseMove )
	{
		data.cursor_x = event.x;
		data.cursor_y = event.y;
		com!UI_Scrollable_doScrolling( 0, this );
	}
}

function UI_MakeScrollable( ctrl, vscroll, hscroll )
{
	vscroll = if( vscroll === null, "auto", vscroll );
	hscroll = if( hscroll === null, "auto", hscroll );
	
	scrV = UI_CreateVScrollbar( ctrl )[]{ nonclient = true };
	scrH = UI_CreateHScrollbar( ctrl )[]{ nonclient = true };
	scrV.addClass( "scroll-v" );
	scrH.addClass( "scroll-h" );
	scrV.bindEvent( "change", function(){ this.parent.scroll_y = -this.data.position; } );
	scrH.bindEvent( "change", function(){ this.parent.scroll_x = -this.data.position; } );
	
	ctrl.addComponent( "scrollable", UI_Scrollable_Proc, {
		scrV = scrV,
		scrH = scrH,
		hscroll = hscroll,
		vscroll = vscroll,
		cursor_scroll = false,
		cursor_x = null,
		cursor_y = null,
		
		enableCursorScroll = function( v ){ this.cursor_scroll = v; },
	});
}


//
// RESIZABLE
//

function UI_Resizable_Proc( event, com )
{
	data = com.data;
	ML = if( data.margin_l === null, this.nonClientLeft, data.margin_l );
	MT = if( data.margin_t === null, this.nonClientLeft, data.margin_t );
	MR = if( data.margin_r === null, this.nonClientLeft, data.margin_r );
	MB = if( data.margin_b === null, this.nonClientLeft, data.margin_b );
	if( event.type == EV_ButtonDown )
	{
		if( event.button == Mouse_ButtonL )
		{
			// test for resizing
			rsz = 0;
			if( event.x >= this.rx0 && event.x <= this.rx0 + ML ) rsz |= 0b0001;
			if( event.x >= this.rx1 - MR && event.x <= this.rx1 ) rsz |= 0b0010;
			if( event.y >= this.ry0 && event.y <= this.ry0 + MT ) rsz |= 0b0100;
			if( event.y >= this.ry1 - MB && event.y <= this.ry1 ) rsz |= 0b1000;
			if( rsz )
				data.setDragging( this, rsz, event );
		}
	}
	else if( event.type == EV_ButtonUp )
	{
		if( event.button == Mouse_ButtonL )
			data.setDragging( this, null, null, event );
	}
	else if( event.type == EV_MouseMove )
	{
		this.cursor = true;
		rsz = 0;
		if( event.x >= this.rx0 && event.x <= this.rx0 + ML ) rsz |= 0b0001;
		if( event.x >= this.rx1 - MR && event.x <= this.rx1 ) rsz |= 0b0010;
		if( event.y >= this.ry0 && event.y <= this.ry0 + MT ) rsz |= 0b0100;
		if( event.y >= this.ry1 - MB && event.y <= this.ry1 ) rsz |= 0b1000;
		
		if( rsz == 0b0101 || rsz == 0b1010 ) this.cursor = UI_Cursor_SizeNWSE;
		else if( rsz == 0b0110 || rsz == 0b1001 ) this.cursor = UI_Cursor_SizeNESW;
		else if( rsz == 0b0001 || rsz == 0b0010 ) this.cursor = UI_Cursor_SizeWE;
		else if( rsz == 0b0100 || rsz == 0b1000 ) this.cursor = UI_Cursor_SizeNS;
		
		data.handleDragging( this, event );
	}
}

function UI_MakeResizable( ctrl, left, top, right, bottom )
{
	Resizable_data =
	{
		margin_l = left,
		margin_t = top,
		margin_r = right,
		margin_b = bottom,
		dragging = null,
		dragorig_x = null,
		dragorig_y = null,
		dragstart_x = null,
		dragstart_y = null,
		hasdragged = false,
	};
	
	function Resizable_data.setDragging( Resizable, type, cursor, event )
	{
		this.dragging = type;
		if( type !== null )
		{
			if( type & 0b0010 )
				this.dragorig_x = Resizable.width;
			else
				this.dragorig_x = Resizable.x;
			
			if( type & 0b1000 )
				this.dragorig_y = Resizable.height;
			else
				this.dragorig_y = Resizable.y;
			
			this.dragstart_x = cursor.x;
			this.dragstart_y = cursor.y;
			this.hasdragged = false;
		}
		else if( this.hasdragged )
		{
			if( !event )
				event = UI_CreateEvent();
			Resizable.callEvent( "onresize", event );
		}
	}
	
	function Resizable_data.handleDragging( Resizable, event )
	{
		if( this.dragging === null )
			return;
		if( !this.hasdragged )
		{
			Resizable.callEvent( "onbeforesize", event );
			this.hasdragged = true;
		}
		if( this.dragging === 0 )
		{
			Resizable.x = this.dragorig_x + event.x - this.dragstart_x;
			Resizable.y = this.dragorig_y + event.y - this.dragstart_y;
		}
		else
		{
			if( this.dragging & 0b0010 )
				Resizable.width = this.dragorig_x + event.x - this.dragstart_x;
			else if( this.dragging & 0b0001 )
				Resizable.offsetLeft = this.dragorig_x + event.x - this.dragstart_x;
			
			if( this.dragging & 0b1000 )
				Resizable.height = this.dragorig_y + event.y - this.dragstart_y;
			else if( this.dragging & 0b0100 )
				Resizable.offsetTop = this.dragorig_y + event.y - this.dragstart_y;
		}
		Resizable.callEvent( "oneditsize", event );
	}
	
	ctrl.addComponent( "resizable", UI_Resizable_Proc, Resizable_data );
}

