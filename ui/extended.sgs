

global UI_ScrollingAutoLayout = {};

function UI_ScrollingAutoLayout.getContainer()
{
	return this.data.OpCont;
}

function UI_CreateScrollingAutoLayout( parent )
{
	ScrollingAutoLayout = parent.frame.createControl( "scrollingautolayout" );
	ScrollingAutoLayout._interface = UI_ScrollingAutoLayout;
	ScrollingAutoLayout.data =
	{
		options = [],
	};
	
	Scrollable = UI_CreateScrollable( ScrollingAutoLayout, "auto", false );
	ScrollingAutoLayout.data.Scrollable = Scrollable;
	
	AutoLayout = UI_CreateAutoLayout( Scrollable );
	ScrollingAutoLayout.data.AutoLayout = AutoLayout;
	ScrollingAutoLayout.data.OpCont = AutoLayout;
	
	ScrollingAutoLayout.updateTheme();
	parent.addChild( ScrollingAutoLayout );
	return ScrollingAutoLayout;
}

UI_Controls.scrollingautolayout_params = ["children"];
function UI_Controls.scrollingautolayout( parent, params )
{
	ctrl = UI_CreateScrollingAutoLayout( parent );
	UI_ConfigControl( ctrl, params );
	if( @params.children )
		UI_BuildControls( ctrl.getContainer(), params.children );
}


global UI_ListBoxMenu = {};

function UI_ListBoxMenu.addOption( option )
{
	data = this.data;
	data.options.push( option );
	
	return UI_CreateButton( data.OpCont )[]{ caption = option.text, icon = @option.icon };
}

function UI_CreateListBoxMenu( parent )
{
	ListBoxMenu = parent.frame.createControl( "listboxmenu" );
	ListBoxMenu._interface = UI_ListBoxMenu;
	ListBoxMenu.data =
	{
		options = [],
	};
	
	Scrollable = UI_CreateScrollable( ListBoxMenu, "auto", false );
	ListBoxMenu.data.Scrollable = Scrollable;
	
	AutoLayout = UI_CreateAutoLayout( Scrollable );
	ListBoxMenu.data.AutoLayout = AutoLayout;
	ListBoxMenu.data.OpCont = AutoLayout;
	
	ListBoxMenu.updateTheme();
	parent.addChild( ListBoxMenu );
	return ListBoxMenu;
}

UI_Controls.listboxmenu_params = [];
function UI_Controls.listboxmenu( parent, params )
{
	ctrl = UI_CreateListBoxMenu( parent );
	UI_ConfigControl( ctrl, params );
}


global UI_PropertyGrid = {};

function UI_PropertyGrid._create_label( text )
{
	data = this.data;
	ctrl = UI_CreateStatic( data.OpCont )[]{ caption = text }.addClass( "label" );
	return ctrl;
}

function UI_PropertyGrid._createDefaultLabel( name, option )
{
	return this._create_label( @option.label || name );
}

function UI_PropertyGrid._create_checkbox( name, value, option )
{
	this._createDefaultLabel( name, option );
	
	data = this.data;
	ctrl = UI_CreateCheckbox( data.OpCont, name, null, !!value ).addClass( "value" );
	return ctrl;
}

function UI_PropertyGrid._create_slider( name, value, option )
{
	this._createDefaultLabel( name, option );
	
	data = this.data;
	ctrl = UI_CreateSlider( data.OpCont, name, @option.min, @option.max, @option.stopsize ).addClass( "value" );
	ctrl.setValue( value );
	return ctrl;
}

function UI_PropertyGrid._create_textbox( name, value, option )
{
	this._createDefaultLabel( name, option );
	
	data = this.data;
	ctrl = UI_CreateTextbox( data.OpCont, name, @option.textbox_caption, value ).addClass( "value" );
	return ctrl;
}

function UI_PropertyGrid._create_switchbutton( name, value, option )
{
	this._createDefaultLabel( name, option );
	
	data = this.data;
	ctrl = UI_CreateSwitchButton( data.OpCont, name, @option.options, @option.sidebuttons, value ).addClass( "value" );
	return ctrl;
}

function UI_PropertyGrid._create_button( name, value, option )
{
	data = this.data;
	ctrl = UI_CreateButton( data.OpCont )[]{ caption = @option.label || name, icon = @option.icon, class = "value" };
	ctrl.bindEvent( "click", value );
	return ctrl;
}

function UI_PropertyGrid.getType( value, option )
{
	if( @option.type )
		return option.type;
	if( typeid( value ) == VT_BOOL ) return "checkbox", toint;
	if( is_callable( value ) ) return "button", null;
	return "textbox", tostring;
}

function UI_PropertyGrid.setData( input_values, options )
{
	if( input_values === null )
		return;
	data = this.data;
	all_values = {};
	options ||= {};
	data.options = options;
	foreach( k, v : input_values )
	{
		if( is_callable( v ) )
			continue;
		all_values[ k ] = v;
		if( !isset( options, k ) )
			options[ k ] = {};
		option = options[ k ];
		if( !isset( option, "convert" ) )
		{
			(type,convfunc) = this.getType( v, option );
			option.convert = convfunc;
		}
	}
	data.values = all_values;
	
	// Rebuild options
	data.OpCont.removeAllChildren();
	foreach( k, v : input_values )
	{
		option = @options[ k ];
		type = this.getType( v, option );
		this.("_create_"$type)( k, v, option );
	}
}

function UI_PropertyGrid._updateData()
{
	data = this.data;
	form = data.Form;
	foreach( k, : data.values )
	{
		fditem = form.getString( k );
		if( fditem !== null )
		{
			option = @data.options.(k);
			if( @option.convert )
				fditem = option.convert( fditem );
			data.values[ k ] = fditem;
		}
	}
}

function UI_PropertyGrid.getData()
{
	return this.data.values;
}

function UI_PropertyGrid.getValueOf( name )
{
	return @this.data.values[ name ];
}

function UI_CreatePropertyGrid( parent, seed, options )
{
	PropertyGrid = parent.frame.createControl( "propertygrid" );
	PropertyGrid._interface = UI_PropertyGrid;
	PropertyGrid.data =
	{
		label_width_min = 0,
		label_width_max = UI_MaxValue,
		label_width_percent = 0.5,
		label_height = 24,
		value_width_min = 0,
		value_width_max = UI_MaxValue,
		value_width_percent = 0.5,
		value_height = 24,
		
		values = {},
		options = {},
	};
	
	Form = UI_CreateForm( PropertyGrid );
	PropertyGrid.data.Form = Form;
	Form.bindEvent( "change", function( e ){ this.parent._updateData(); this.parent.callEvent( "change", e ); } );
	
	Scrollable = UI_CreateScrollable( Form, "auto", false );
	PropertyGrid.data.Scrollable = Scrollable;
	
	AutoLayout = UI_CreateAutoLayout( Scrollable );
	PropertyGrid.data.AutoLayout = AutoLayout;
	PropertyGrid.data.OpCont = AutoLayout;
	
	parent.addChild( PropertyGrid );
	
	PropertyGrid.setData( seed, options );
	
	return PropertyGrid;
}

UI_Controls.propertygrid_params = ["seed","options"];
function UI_Controls.propertygrid( parent, params )
{
	ctrl = UI_CreatePropertyGrid( parent, @params.seed, @params.options );
	UI_ConfigControl( ctrl, params );
}


global UI_Window = {};

function UI_Window.adjustSize()
{
	this.x -= this.nonClientLeft;
	this.y -= this.nonClientTop;
	this.width += this.nonClientLeft + this.nonClientRight;
	this.height += this.nonClientTop + this.nonClientBottom;
	return this;
}

function UI_CreateWindow( parent )
{
	Window = parent.frame.createControl( "window" );
	Window.data =
	{
		dragging = null,
		dragorig_x = null,
		dragorig_y = null,
		dragstart_x = null,
		dragstart_y = null,
	};
	Window._interface = UI_Window;
	
	Window_data = Window.data;
	function Window_data.setDragging( Window, type, cursor )
	{
		this.dragging = type;
		if( type !== null )
		{
			if( type & 0b0010 )
				this.dragorig_x = Window.width;
			else
				this.dragorig_x = Window.x;
			
			if( type & 0b1000 )
				this.dragorig_y = Window.height;
			else
				this.dragorig_y = Window.y;
			
			this.dragstart_x = cursor.x;
			this.dragstart_y = cursor.y;
		}
	}
	function Window_data.handleDragging( Window, cursor )
	{
		if( this.dragging === null )
			return;
		if( this.dragging === 0 )
		{
			Window.x = this.dragorig_x + cursor.x - this.dragstart_x;
			Window.y = this.dragorig_y + cursor.y - this.dragstart_y;
		}
		else
		{
			if( this.dragging & 0b0010 )
				Window.width = this.dragorig_x + cursor.x - this.dragstart_x;
			else if( this.dragging & 0b0001 )
				Window.offsetLeft = this.dragorig_x + cursor.x - this.dragstart_x;
			
			if( this.dragging & 0b1000 )
				Window.height = this.dragorig_y + cursor.y - this.dragstart_y;
			else if( this.dragging & 0b0100 )
				Window.offsetTop = this.dragorig_y + cursor.y - this.dragstart_y;
		}
	}
	
	CloseBtn = UI_CreateButton( Window )[]{ class = "close-button" };
	CloseBtn.nonclient = true;
	CloseBtn.bindEvent( "click", function(){ this.parent.destroy(true); } );
	Window.data.CloseBtn = CloseBtn;
	
	ocb = Window.callback;
	function Window.callback( event ) use( ocb )
	{
		data = this.data;
		if( event.type == EV_ButtonDown )
		{
			if( event.button == Mouse_ButtonL )
			{
				// test for dragging
				if( event.x >= this.rx0 + 4 && event.x < this.rx1 - 4 &&
					event.y >= this.ry0 + 4 && event.y < this.ry0 + 24 )
					data.setDragging( this, 0, event );
				// test for resizing
				rsz = 0;
				if( event.x >= this.rx0 && event.x <= this.rx0 + 4 ) rsz |= 0b0001;
				if( event.x >= this.rx1 - 4 && event.x <= this.rx1 ) rsz |= 0b0010;
				if( event.y >= this.ry0 && event.y <= this.ry0 + 4 ) rsz |= 0b0100;
				if( event.y >= this.ry1 - 4 && event.y <= this.ry1 ) rsz |= 0b1000;
				if( rsz )
					data.setDragging( this, rsz, event );
			}
		}
		else if( event.type == EV_ButtonUp )
		{
			if( event.button == Mouse_ButtonL )
				data.setDragging( this, null );
		}
		else if( event.type == EV_MouseMove )
		{
			this.cursor = true;
			rsz = 0;
			if( event.x >= this.rx0 && event.x <= this.rx0 + 4 ) rsz |= 0b0001;
			if( event.x >= this.rx1 - 4 && event.x <= this.rx1 ) rsz |= 0b0010;
			if( event.y >= this.ry0 && event.y <= this.ry0 + 4 ) rsz |= 0b0100;
			if( event.y >= this.ry1 - 4 && event.y <= this.ry1 ) rsz |= 0b1000;
			
			if( rsz == 0b0101 || rsz == 0b1010 ) this.cursor = UI_Cursor_SizeNWSE;
			else if( rsz == 0b0110 || rsz == 0b1001 ) this.cursor = UI_Cursor_SizeNESW;
			else if( rsz == 0b0001 || rsz == 0b0010 ) this.cursor = UI_Cursor_SizeWE;
			else if( rsz == 0b0100 || rsz == 0b1000 ) this.cursor = UI_Cursor_SizeNS;
			
			data.handleDragging( this, event );
		}
		return this!ocb( event );
	}
	
	Window.updateTheme();
	parent.addChild( Window );
	return Window;
}

UI_Controls.window_params = [];
function UI_Controls.window( parent, params )
{
	ctrl = UI_CreateWindow( parent );
	UI_ConfigControl( ctrl, params );
}

